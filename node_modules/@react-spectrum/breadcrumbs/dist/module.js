import { useProviderProps } from "@react-spectrum/provider";
import { Menu, MenuTrigger } from "@react-spectrum/menu";
import _spectrumIconsUiFolderBreadcrumb from "@spectrum-icons/ui/FolderBreadcrumb";
import { useLocale } from "@react-aria/i18n";
import { useHover } from "@react-aria/interactions";
import { useBreadcrumbItem, useBreadcrumbs } from "@react-aria/breadcrumbs";
import _react, { Fragment, useRef, useCallback, useEffect, useLayoutEffect, useState } from "react";
import { mergeProps } from "@react-aria/utils";
import { FocusRing } from "@react-aria/focus";
import { classNames, getWrappedElement, useDOMRef, useStyleProps } from "@react-spectrum/utils";
import _spectrumIconsUiChevronRightSmall from "@spectrum-icons/ui/ChevronRightSmall";
import { ActionButton } from "@react-spectrum/button";
import _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose from "@babel/runtime/helpers/esm/objectWithoutPropertiesLoose";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
import { Item } from "@react-stately/collections";
export { Item };
import "./main.css";

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

// ASSET: /Users/govett/dev/react-spectrum-v3/node_modules/@adobe/spectrum-css-temp/components/breadcrumb/vars.css
var $a5baa762b556403ac2f1cf2374238631$exports = {};
$a5baa762b556403ac2f1cf2374238631$exports = {
  "spectrum-Breadcrumbs": "_spectrum-Breadcrumbs_e7b3e",
  "spectrum-Breadcrumbs-itemSeparator": "_spectrum-Breadcrumbs-itemSeparator_e7b3e",
  "is-reversed": "_is-reversed_e7b3e",
  "spectrum-Breadcrumbs-item": "_spectrum-Breadcrumbs-item_e7b3e",
  "spectrum-ActionButton": "_spectrum-ActionButton_e7b3e",
  "spectrum-Breadcrumbs-itemLink": "_spectrum-Breadcrumbs-itemLink_e7b3e",
  "is-hovered": "_is-hovered_e7b3e",
  "focus-ring": "_focus-ring_e7b3e",
  "is-dragged": "_is-dragged_e7b3e",
  "spectrum-Breadcrumbs--small": "_spectrum-Breadcrumbs--small_e7b3e",
  "spectrum-Breadcrumbs--medium": "_spectrum-Breadcrumbs--medium_e7b3e",
  "spectrum-Breadcrumbs--multiline": "_spectrum-Breadcrumbs--multiline_e7b3e",
  "spectrum-Heading--pageTitle": "_spectrum-Heading--pageTitle_e7b3e",
  "is-disabled": "_is-disabled_e7b3e",
  "is-selected": "_is-selected_e7b3e",
  "spectrum-Breadcrumb": "_spectrum-Breadcrumb_e7b3e"
};
var $a5baa762b556403ac2f1cf2374238631$$interop$default = $parcel$interopDefault($a5baa762b556403ac2f1cf2374238631$exports);

function $dacda927994e51fbe8a71ffbc$export$BreadcrumbItem(props) {
  let {
    children,
    isCurrent,
    isDisabled
  } = props;
  let {
    direction
  } = useLocale();
  let ref = useRef();
  let {
    itemProps
  } = useBreadcrumbItem(_babelRuntimeHelpersEsmExtends({}, props, {
    elementType: typeof children === 'string' ? 'span' : 'a'
  }), ref);
  let {
    hoverProps,
    isHovered
  } = useHover(props);

  let element = _react.cloneElement(getWrappedElement(children), _babelRuntimeHelpersEsmExtends({}, mergeProps(itemProps, hoverProps), {
    ref,
    className: classNames($a5baa762b556403ac2f1cf2374238631$$interop$default, 'spectrum-Breadcrumbs-itemLink', {
      'is-disabled': !isCurrent && isDisabled,
      'is-hovered': isHovered
    })
  }));

  return /*#__PURE__*/_react.createElement(Fragment, null, /*#__PURE__*/_react.createElement(FocusRing, {
    focusRingClass: classNames($a5baa762b556403ac2f1cf2374238631$$interop$default, 'focus-ring')
  }, element), isCurrent === false && /*#__PURE__*/_react.createElement(_spectrumIconsUiChevronRightSmall, {
    UNSAFE_className: classNames($a5baa762b556403ac2f1cf2374238631$$interop$default, 'spectrum-Breadcrumbs-itemSeparator', {
      'is-reversed': direction === 'rtl'
    })
  }));
}

const $ca93a0b524bf6d5b2a180315b966bddc$var$MIN_VISIBLE_ITEMS = 1;
const $ca93a0b524bf6d5b2a180315b966bddc$var$MAX_VISIBLE_ITEMS = 4;

function $ca93a0b524bf6d5b2a180315b966bddc$var$Breadcrumbs(props, ref) {
  props = useProviderProps(props);

  let {
    size = 'L',
    isMultiline,
    children,
    showRoot,
    isDisabled,
    onAction
  } = props,
      otherProps = _babelRuntimeHelpersEsmObjectWithoutPropertiesLoose(props, ["size", "isMultiline", "children", "showRoot", "isDisabled", "onAction"]); // Not using React.Children.toArray because it mutates the key prop.


  let childArray = [];

  _react.Children.forEach(children, child => {
    if (_react.isValidElement(child)) {
      childArray.push(child);
    }
  });

  let domRef = useDOMRef(ref);
  let listRef = useRef(null);
  let [visibleItems, setVisibleItems] = $ca93a0b524bf6d5b2a180315b966bddc$var$useValueEffect(childArray.length);
  let {
    navProps
  } = useBreadcrumbs(props);
  let {
    styleProps
  } = useStyleProps(otherProps);
  let updateOverflow = useCallback(() => {
    let computeVisibleItems = visibleItems => {
      let listItems = Array.from(listRef.current.children);
      let containerWidth = listRef.current.offsetWidth;
      let isShowingMenu = childArray.length > visibleItems;
      let calculatedWidth = 0;
      let newVisibleItems = 0;
      let maxVisibleItems = $ca93a0b524bf6d5b2a180315b966bddc$var$MAX_VISIBLE_ITEMS;

      if (showRoot) {
        calculatedWidth += listItems.shift().offsetWidth;
        newVisibleItems++;
      }

      if (isShowingMenu) {
        calculatedWidth += listItems.shift().offsetWidth;
        maxVisibleItems--;
      }

      if (showRoot && calculatedWidth >= containerWidth) {
        newVisibleItems--;
      } // TODO: what if multiline and only one breadcrumb??


      if (isMultiline) {
        listItems.pop();
        newVisibleItems++;
      } else {
        // Ensure the last breadcrumb isn't truncated when we measure it.
        let last = listItems.pop();
        last.style.overflow = 'visible';
        calculatedWidth += last.offsetWidth;

        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }

        last.style.overflow = '';
      }

      for (let breadcrumb of listItems.reverse()) {
        calculatedWidth += breadcrumb.offsetWidth;

        if (calculatedWidth < containerWidth) {
          newVisibleItems++;
        }
      }

      return Math.max($ca93a0b524bf6d5b2a180315b966bddc$var$MIN_VISIBLE_ITEMS, Math.min(maxVisibleItems, newVisibleItems));
    };

    setVisibleItems(function* () {
      // Update to show all items.
      yield childArray.length; // Measure, and update to show the items that fit.

      let newVisibleItems = computeVisibleItems(childArray.length);
      yield newVisibleItems; // If the number of items is less than the number of children,
      // then update again to ensure that the menu fits.

      if (newVisibleItems < childArray.length && newVisibleItems > 1) {
        yield computeVisibleItems(newVisibleItems);
      }
    });
  }, [listRef, children, setVisibleItems, showRoot, isMultiline]);
  useEffect(() => {
    window.addEventListener('resize', updateOverflow, false);
    return () => {
      window.removeEventListener('resize', updateOverflow, false);
    };
  }, [updateOverflow]);
  useLayoutEffect(updateOverflow, [children]);
  let contents = childArray;

  if (childArray.length > visibleItems) {
    var _selectedItem$key;

    let selectedItem = childArray[childArray.length - 1];
    let selectedKey = (_selectedItem$key = selectedItem.key) != null ? _selectedItem$key : childArray.length - 1;

    let onMenuAction = key => {
      // Don't fire onAction when clicking on the last item
      if (key !== selectedKey && onAction) {
        onAction(key);
      }
    };

    let menuItem = /*#__PURE__*/_react.createElement($dacda927994e51fbe8a71ffbc$export$BreadcrumbItem, {
      key: "menu"
    }, /*#__PURE__*/_react.createElement(MenuTrigger, null, /*#__PURE__*/_react.createElement(ActionButton, {
      "aria-label": "\u2026",
      isQuiet: true,
      isDisabled: isDisabled
    }, /*#__PURE__*/_react.createElement(_spectrumIconsUiFolderBreadcrumb, null)), /*#__PURE__*/_react.createElement(Menu, {
      selectionMode: "single",
      selectedKeys: [selectedKey],
      onAction: onMenuAction
    }, childArray)));

    contents = [menuItem];
    let breadcrumbs = [...childArray];
    let endItems = visibleItems;

    if (showRoot && visibleItems > 1) {
      contents.unshift(breadcrumbs.shift());
      endItems--;
    }

    contents.push(...breadcrumbs.slice(-endItems));
  }

  let lastIndex = contents.length - 1;
  let breadcrumbItems = contents.map((child, index) => {
    var _child$key;

    let isCurrent = index === lastIndex;
    let key = (_child$key = child.key) != null ? _child$key : index;

    let onPress = () => {
      if (onAction) {
        onAction(key);
      }
    };

    return /*#__PURE__*/_react.createElement("li", {
      key: key,
      className: classNames($a5baa762b556403ac2f1cf2374238631$$interop$default, 'spectrum-Breadcrumbs-item')
    }, /*#__PURE__*/_react.createElement($dacda927994e51fbe8a71ffbc$export$BreadcrumbItem, {
      isCurrent: isCurrent,
      isDisabled: isDisabled,
      onPress: onPress
    }, child.props.children));
  });
  return /*#__PURE__*/_react.createElement("nav", _babelRuntimeHelpersEsmExtends({}, styleProps, navProps, {
    ref: domRef
  }), /*#__PURE__*/_react.createElement("ul", {
    ref: listRef,
    className: classNames($a5baa762b556403ac2f1cf2374238631$$interop$default, 'spectrum-Breadcrumbs', {
      'spectrum-Breadcrumbs--small': size === 'S',
      'spectrum-Breadcrumbs--medium': size === 'M',
      'spectrum-Breadcrumbs--multiline': isMultiline,
      'spectrum-Breadcrumbs--showRoot': showRoot,
      'is-disabled': isDisabled
    }, styleProps.className)
  }, breadcrumbItems));
} // This hook works like `useState`, but when setting the value, you pass a generator function
// that can yield multiple values. Each yielded value updates the state and waits for the next
// layout effect, then continues the generator. This allows sequential updates to state to be
// written linearly.


function $ca93a0b524bf6d5b2a180315b966bddc$var$useValueEffect(defaultValue) {
  let [value, setValue] = useState(defaultValue);
  let effect = useRef(null); // Store the function in a ref so we can always access the current version
  // which has the proper `value` in scope.

  let nextRef = useRef(null);

  nextRef.current = () => {
    // Run the generator to the next yield.
    let newValue = effect.current.next(); // If the generator is done, reset the effect.

    if (newValue.done) {
      effect.current = null;
      return;
    } // If the value is the same as the current value,
    // then continue to the next yield. Otherwise,
    // set the value in state and wait for the next layout effect.


    if (value === newValue.value) {
      nextRef.current();
    } else {
      setValue(newValue.value);
    }
  };

  useLayoutEffect(() => {
    // If there is an effect currently running, continue to the next yield.
    if (effect.current) {
      nextRef.current();
    }
  });
  let queue = useCallback(fn => {
    effect.current = fn();
    nextRef.current();
  }, [effect, nextRef]);
  return [value, queue];
}
/**
 * Breadcrumbs show hierarchy and navigational context for a user’s location within an application.
 */


export let Breadcrumbs = _react.forwardRef($ca93a0b524bf6d5b2a180315b966bddc$var$Breadcrumbs);
//# sourceMappingURL=module.js.map
