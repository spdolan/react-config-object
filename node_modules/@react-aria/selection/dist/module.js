import { useCollator } from "@react-aria/i18n";
import { getFocusableTreeWalker } from "@react-aria/focus";
import { focusWithoutScrolling, mergeProps } from "@react-aria/utils";
import { useEffect, useRef, useMemo } from "react";

/**
 * Handles typeahead interactions with collections.
 */
export function useTypeSelect(options) {
  let {
    keyboardDelegate,
    selectionManager,
    onTypeSelect
  } = options;
  let state = useRef({
    search: '',
    timeout: null
  }).current;

  let onKeyDown = e => {
    let character = $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(e.key);

    if (!character || e.ctrlKey || e.metaKey) {
      return;
    }

    state.search += character; // Use the delegate to find a key to focus.
    // Prioritize items after the currently focused item, falling back to searching the whole list.

    let key = keyboardDelegate.getKeyForSearch(state.search, selectionManager.focusedKey); // If no key found, search from the top.

    key = key || keyboardDelegate.getKeyForSearch(state.search);

    if (key) {
      selectionManager.setFocusedKey(key);

      if (onTypeSelect) {
        onTypeSelect(key);
      }
    }

    clearTimeout(state.timeout);
    state.timeout = setTimeout(() => {
      state.search = '';
    }, 500);
  };

  return {
    typeSelectProps: {
      onKeyDown: keyboardDelegate.getKeyForSearch ? onKeyDown : null
    }
  };
}

function $c78d7fa5f7d5832f9b4f97b33a679865$var$getStringForKey(key) {
  // If the key is of length 1, it is an ASCII value.
  // Otherwise, if there are no ASCII characters in the key name,
  // it is a Unicode character.
  // See https://www.w3.org/TR/uievents-key/
  if (key.length === 1 || !/^[A-Z]/i.test(key)) {
    return key;
  }

  return '';
}

const $a9b9aa71af07c56ab1d89ca45381f4b$var$isMac = typeof window !== 'undefined' && window.navigator != null ? /^Mac/.test(window.navigator.platform) : false;

function $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) {
  if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isMac) {
    return e.metaKey;
  }

  return e.ctrlKey;
}

/**
 * Handles interactions with selectable collections.
 */
export function useSelectableCollection(options) {
  let {
    selectionManager: manager,
    keyboardDelegate: delegate,
    ref,
    autoFocus = false,
    shouldFocusWrap = false,
    disallowEmptySelection = false,
    disallowSelectAll = false
  } = options;

  let onKeyDown = e => {
    // Let child element (e.g. menu button) handle the event if the Alt key is pressed.
    // Keyboard events bubble through portals. Don't handle keyboard events
    // for elements outside the collection (e.g. menus).
    if (e.altKey || !ref.current.contains(e.target)) {
      return;
    }

    switch (e.key) {
      case 'ArrowDown':
        {
          if (delegate.getKeyBelow) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyBelow(manager.focusedKey) : delegate.getFirstKey();

            if (nextKey) {
              manager.setFocusedKey(nextKey);
            } else if (shouldFocusWrap) {
              manager.setFocusedKey(delegate.getFirstKey(manager.focusedKey));
            }

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }

          break;
        }

      case 'ArrowUp':
        {
          if (delegate.getKeyAbove) {
            e.preventDefault();
            let nextKey = manager.focusedKey != null ? delegate.getKeyAbove(manager.focusedKey) : delegate.getLastKey();

            if (nextKey) {
              manager.setFocusedKey(nextKey);
            } else if (shouldFocusWrap) {
              manager.setFocusedKey(delegate.getLastKey(manager.focusedKey));
            }

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }

          break;
        }

      case 'ArrowLeft':
        {
          if (delegate.getKeyLeftOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyLeftOf(manager.focusedKey);

            if (nextKey) {
              manager.setFocusedKey(nextKey);
            }

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }

          break;
        }

      case 'ArrowRight':
        {
          if (delegate.getKeyRightOf) {
            e.preventDefault();
            let nextKey = delegate.getKeyRightOf(manager.focusedKey);

            if (nextKey) {
              manager.setFocusedKey(nextKey);
            }

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }

          break;
        }

      case 'Home':
        if (delegate.getFirstKey) {
          e.preventDefault();
          let firstKey = delegate.getFirstKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(firstKey);

          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(firstKey);
          }
        }

        break;

      case 'End':
        if (delegate.getLastKey) {
          e.preventDefault();
          let lastKey = delegate.getLastKey(manager.focusedKey, $a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e));
          manager.setFocusedKey(lastKey);

          if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && e.shiftKey && manager.selectionMode === 'multiple') {
            manager.extendSelection(lastKey);
          }
        }

        break;

      case 'PageDown':
        if (delegate.getKeyPageBelow) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageBelow(manager.focusedKey);

          if (nextKey) {
            manager.setFocusedKey(nextKey);

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }
        }

        break;

      case 'PageUp':
        if (delegate.getKeyPageAbove) {
          e.preventDefault();
          let nextKey = delegate.getKeyPageAbove(manager.focusedKey);

          if (nextKey) {
            manager.setFocusedKey(nextKey);

            if (e.shiftKey && manager.selectionMode === 'multiple') {
              manager.extendSelection(nextKey);
            }
          }
        }

        break;

      case 'a':
        if ($a9b9aa71af07c56ab1d89ca45381f4b$var$isCtrlKeyPressed(e) && manager.selectionMode === 'multiple' && disallowSelectAll !== true) {
          e.preventDefault();
          manager.selectAll();
        }

        break;

      case 'Escape':
        e.preventDefault();

        if (!disallowEmptySelection) {
          manager.clearSelection();
        }

        break;

      case 'Tab':
        {
          // There may be elements that are "tabbable" inside a collection (e.g. in a grid cell).
          // However, collections should be treated as a single tab stop, with arrow key navigation internally.
          // We don't control the rendering of these, so we can't override the tabIndex to prevent tabbing.
          // Instead, we handle the Tab key, and move focus manually to the first/last tabbable element
          // in the collection, so that the browser default behavior will apply starting from that element
          // rather than the currently focused one.
          if (e.shiftKey) {
            ref.current.focus();
          } else {
            let walker = getFocusableTreeWalker(ref.current, {
              tabbable: true
            });
            let next;
            let last;

            do {
              last = walker.lastChild();

              if (last) {
                next = last;
              }
            } while (last);

            if (next && !next.contains(document.activeElement)) {
              next.focus();
            }
          }

          break;
        }
    }
  };

  let onFocus = e => {
    if (manager.isFocused) {
      // If a focus event bubbled through a portal, reset focus state.
      if (!e.currentTarget.contains(e.target)) {
        manager.setFocused(false);
      }

      return;
    } // Focus events can bubble through portals. Ignore these events.


    if (!e.currentTarget.contains(e.target)) {
      return;
    }

    manager.setFocused(true);

    if (manager.focusedKey == null) {
      // If the user hasn't yet interacted with the collection, there will be no focusedKey set.
      // Attempt to detect whether the user is tabbing forward or backward into the collection
      // and either focus the first or last item accordingly.
      let relatedTarget = e.relatedTarget;

      if (relatedTarget && e.currentTarget.compareDocumentPosition(relatedTarget) & Node.DOCUMENT_POSITION_FOLLOWING) {
        manager.setFocusedKey(delegate.getLastKey());
      } else {
        manager.setFocusedKey(delegate.getFirstKey());
      }
    }
  };

  let onBlur = e => {
    // Don't set blurred and then focused again if moving focus within the collection.
    if (!e.currentTarget.contains(e.relatedTarget)) {
      manager.setFocused(false);
    }
  };

  useEffect(() => {
    if (autoFocus) {
      let focusedKey = null; // Check focus strategy to determine which item to focus

      if (autoFocus === 'first') {
        focusedKey = delegate.getFirstKey();
      }

      if (autoFocus === 'last') {
        focusedKey = delegate.getLastKey();
      } // If there are any selected keys, make the first one the new focus target


      let selectedKeys = manager.selectedKeys;

      if (selectedKeys.size) {
        focusedKey = selectedKeys.values().next().value;
      }

      manager.setFocused(true);
      manager.setFocusedKey(focusedKey); // If no default focus key is selected, focus the collection itself.

      if (focusedKey == null) {
        focusWithoutScrolling(ref.current);
      }
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, []);
  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: manager
  });
  return {
    collectionProps: mergeProps(typeSelectProps, {
      tabIndex: -1,
      // We use a capturing listener to ensure that the keyboard events for the collection
      // override those of the children. For example, ArrowDown in a table should always go
      // to the cell below, and not open a menu.
      onKeyDownCapture: onKeyDown,
      onFocus,
      onBlur,

      onMouseDown(e) {
        // Prevent focus going to the collection when clicking on the scrollbar.
        e.preventDefault();
      }

    })
  };
}

/**
 * Handles interactions with an item in a selectable collection.
 */
export function useSelectableItem(options) {
  let {
    selectionManager: manager,
    key,
    ref,
    shouldSelectOnPressUp,
    isVirtualized,
    focus
  } = options;

  let onSelect = e => {
    if (manager.selectionMode === 'none') {
      return;
    }

    if (manager.selectionMode === 'single') {
      if (manager.isSelected(key) && !manager.disallowEmptySelection) {
        manager.toggleSelection(key);
      } else {
        manager.replaceSelection(key);
      }
    } else if (e.shiftKey) {
      manager.extendSelection(key);
    } else if (manager) {
      manager.toggleSelection(key);
    }
  }; // Focus the associated DOM node when this item becomes the focusedKey


  let isFocused = key === manager.focusedKey;
  useEffect(() => {
    if (isFocused && manager.isFocused && document.activeElement !== ref.current) {
      if (focus) {
        focus();
      } else {
        focusWithoutScrolling(ref.current);
      }
    }
  }, [ref, isFocused, manager.focusedKey, manager.isFocused]);
  let itemProps = {
    tabIndex: isFocused ? 0 : -1,

    onFocus(e) {
      if (e.target === ref.current) {
        manager.setFocusedKey(key);
      }
    }

  }; // By default, selection occurs on pointer down. This can be strange if selecting an
  // item causes the UI to disappear immediately (e.g. menus).
  // If shouldSelectOnPressUp is true, we use onPressUp instead of onPressStart.
  // onPress requires a pointer down event on the same element as pointer up. For menus,
  // we want to be able to have the pointer down on the trigger that opens the menu and
  // the pointer up on the menu item rather than requiring a separate press.
  // For keyboard events, selection still occurs on key down.

  if (shouldSelectOnPressUp) {
    itemProps.onPressStart = e => {
      if (e.pointerType === 'keyboard') {
        onSelect(e);
      }
    };

    itemProps.onPressUp = e => {
      if (e.pointerType !== 'keyboard') {
        onSelect(e);
      }
    };
  } else {
    // On touch, it feels strange to select on touch down, so we special case this.
    itemProps.onPressStart = e => {
      if (e.pointerType !== 'touch') {
        onSelect(e);
      }
    };

    itemProps.onPress = e => {
      if (e.pointerType === 'touch') {
        onSelect(e);
      }
    };
  }

  if (!isVirtualized) {
    itemProps['data-key'] = key;
  }

  return {
    itemProps
  };
}

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
export class ListKeyboardDelegate {
  constructor(collection, disabledKeys, ref, collator) {
    this.collection = void 0;
    this.disabledKeys = void 0;
    this.ref = void 0;
    this.collator = void 0;
    this.collection = collection;
    this.disabledKeys = disabledKeys;
    this.ref = ref;
    this.collator = collator;
  }

  getKeyBelow(key) {
    key = this.collection.getKeyAfter(key);

    while (key) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getKeyAbove(key) {
    key = this.collection.getKeyBefore(key);

    while (key) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getFirstKey() {
    let key = this.collection.getFirstKey();

    while (key) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyAfter(key);
    }
  }

  getLastKey() {
    let key = this.collection.getLastKey();

    while (key) {
      let item = this.collection.getItem(key);

      if (item.type === 'item' && !this.disabledKeys.has(key)) {
        return key;
      }

      key = this.collection.getKeyBefore(key);
    }
  }

  getItem(key) {
    return this.ref.current.querySelector("[data-key=\"" + key + "\"]");
  }

  getKeyPageAbove(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.max(0, item.offsetTop + item.offsetHeight - menu.offsetHeight);

    while (item && item.offsetTop > pageY) {
      key = this.getKeyAbove(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyPageBelow(key) {
    let menu = this.ref.current;
    let item = this.getItem(key);

    if (!item) {
      return null;
    }

    let pageY = Math.min(menu.scrollHeight, item.offsetTop - item.offsetHeight + menu.offsetHeight);

    while (item && item.offsetTop < pageY) {
      key = this.getKeyBelow(key);
      item = this.getItem(key);
    }

    return key;
  }

  getKeyForSearch(search, fromKey) {
    if (!this.collator) {
      return null;
    }

    let collection = this.collection;
    let key = fromKey || this.getFirstKey();

    while (key) {
      let item = collection.getItem(key);
      let substring = item.textValue.slice(0, search.length);

      if (item.textValue && this.collator.compare(substring, search) === 0) {
        return key;
      }

      key = this.getKeyBelow(key);
    }

    return null;
  }

}

/**
 * Handles interactions with a selectable list.
 */
export function useSelectableList(props) {
  let {
    selectionManager,
    collection,
    disabledKeys,
    ref,
    keyboardDelegate,
    autoFocus,
    shouldFocusWrap,
    isVirtualized,
    disallowEmptySelection
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(collection, disabledKeys, ref, collator), [keyboardDelegate, collection, disabledKeys, ref, collator]); // If not virtualized, scroll the focused element into view when the focusedKey changes.
  // When virtualized, Virtualizer handles this internally.

  useEffect(() => {
    if (!isVirtualized && selectionManager.focusedKey) {
      let element = ref.current.querySelector("[data-key=\"" + selectionManager.focusedKey + "\"]");

      if (element) {
        $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(ref.current, element);
      }
    }
  }, [isVirtualized, ref, selectionManager.focusedKey]);
  let {
    collectionProps
  } = useSelectableCollection({
    ref,
    selectionManager,
    keyboardDelegate: delegate,
    autoFocus,
    shouldFocusWrap,
    disallowEmptySelection
  });
  return {
    listProps: collectionProps
  };
}
/**
 * Scrolls `scrollView` so that `element` is visible.
 * Similar to `element.scrollIntoView({block: 'nearest'})` (not supported in Edge),
 * but doesn't affect parents above `scrollView`.
 */

function $a09ba753e08b703267f2392f7fc8e96$var$scrollIntoView(scrollView, element) {
  let offsetX = element.offsetLeft - scrollView.offsetLeft;
  let offsetY = element.offsetTop - scrollView.offsetTop;
  let width = element.offsetWidth;
  let height = element.offsetHeight;
  let x = scrollView.scrollLeft;
  let y = scrollView.scrollTop;
  let maxX = x + scrollView.offsetWidth;
  let maxY = y + scrollView.offsetHeight;

  if (offsetX <= x) {
    x = offsetX;
  } else if (offsetX + width > maxX) {
    x += offsetX + width - maxX;
  }

  if (offsetY <= y) {
    y = offsetY;
  } else if (offsetY + height > maxY) {
    y += offsetY + height - maxY;
  }

  scrollView.scrollLeft = x;
  scrollView.scrollTop = y;
}
//# sourceMappingURL=module.js.map
