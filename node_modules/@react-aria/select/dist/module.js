import { VisuallyHidden } from "@react-aria/visually-hidden";
import { useInteractionModality } from "@react-aria/interactions";
import { useMenuTrigger } from "@react-aria/menu";
import { useLabel } from "@react-aria/label";
import { useCollator } from "@react-aria/i18n";
import { ListKeyboardDelegate, useTypeSelect } from "@react-aria/selection";
import _react, { useMemo } from "react";
import { filterDOMProps, mergeProps, useId } from "@react-aria/utils";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

/**
 * Provides the behavior and accessibility implementation for a select component.
 * A select displays a collapsible list of options and allows a user to select one of them.
 * @param props - Props for the select.
 * @param state - State for the select, as returned by `useListState`.
 */
export function useSelect(props, state, ref) {
  let {
    keyboardDelegate
  } = props; // By default, a KeyboardDelegate is provided which uses the DOM to query layout information (e.g. for page up/page down).
  // When virtualized, the layout object will be passed in as a prop and override this.

  let collator = useCollator({
    usage: 'search',
    sensitivity: 'base'
  });
  let delegate = useMemo(() => keyboardDelegate || new ListKeyboardDelegate(state.collection, state.disabledKeys, null, collator), [keyboardDelegate, state.collection, state.disabledKeys, collator]);
  let {
    menuTriggerProps,
    menuProps
  } = useMenuTrigger({
    type: 'listbox'
  }, state, ref);
  let {
    typeSelectProps
  } = useTypeSelect({
    keyboardDelegate: delegate,
    selectionManager: state.selectionManager,

    onTypeSelect(key) {
      state.setSelectedKey(key);
    }

  });
  let {
    labelProps,
    fieldProps
  } = useLabel(_babelRuntimeHelpersEsmExtends({}, props, {
    labelElementType: 'span'
  }));
  let domProps = filterDOMProps(props, {
    labelable: true
  });
  let triggerProps = mergeProps(mergeProps(menuTriggerProps, fieldProps), typeSelectProps);
  let valueId = useId();
  return {
    labelProps,
    triggerProps: mergeProps(domProps, _babelRuntimeHelpersEsmExtends({}, triggerProps, {
      'aria-labelledby': [triggerProps['aria-labelledby'], triggerProps['aria-label'] && !triggerProps['aria-labelledby'] ? triggerProps.id : null, valueId].filter(Boolean).join(' '),

      onFocus() {
        state.setFocused(true);
      },

      onBlur() {
        state.setFocused(false);
      }

    })),
    valueProps: {
      id: valueId
    },
    menuProps: _babelRuntimeHelpersEsmExtends({}, menuProps, {
      'aria-labelledby': [fieldProps['aria-labelledby'], triggerProps['aria-label'] && !fieldProps['aria-labelledby'] ? triggerProps.id : null].filter(Boolean).join(' ')
    })
  };
}

/**
 * Renders a hidden native `<select>` element, which can be used to support browser
 * form autofill, mobile form navigation, and native form submission.
 */
export function HiddenSelect(props) {
  let {
    state,
    triggerRef,
    label,
    name,
    isDisabled
  } = props;
  let modality = useInteractionModality(); // If used in a <form>, use a hidden input so the value can be submitted to a server.
  // If the collection isn't too big, use a hidden <select> element for this so that browser
  // autofill will work. Otherwise, use an <input type="hidden">.

  if (state.collection.size <= 300) {
    // In Safari, the <select> cannot have `display: none` or `hidden` for autofill to work.
    // In Firefox, there must be a <label> to identify the <select> whereas other browsers
    // seem to identify it just by surrounding text.
    // The solution is to use <VisuallyHidden> to hide the elements, which clips the elements to a
    // 1px rectangle. In addition, we hide from screen readers with aria-hidden, and make the <select>
    // non tabbable with tabIndex={-1}.
    //
    // In mobile browsers, there are next/previous buttons above the software keyboard for navigating
    // between fields in a form. These only support native form inputs that are tabbable. In order to
    // support those, an additional hidden input is used to marshall focus to the button. It is tabbable
    // except when the button is focused, so that shift tab works properly to go to the actual previous
    // input in the form. Using the <select> for this also works, but Safari on iOS briefly flashes
    // the native menu on focus, so this isn't ideal. A font-size of 16px or greater is required to
    // prevent Safari from zooming in on the input when it is focused.
    //
    // If the current interaction modality is null, then the user hasn't interacted with the page yet.
    // In this case, we set the tabIndex to -1 on the input element so that automated accessibility
    // checkers don't throw false-positives about focusable elements inside an aria-hidden parent.
    return /*#__PURE__*/_react.createElement(VisuallyHidden, {
      "aria-hidden": "true"
    }, /*#__PURE__*/_react.createElement("input", {
      type: "text",
      tabIndex: modality == null || state.isFocused || state.isOpen ? -1 : 0,
      style: {
        fontSize: 16
      },
      onFocus: () => triggerRef.current.focus(),
      disabled: isDisabled
    }), /*#__PURE__*/_react.createElement("label", null, label, /*#__PURE__*/_react.createElement("select", {
      tabIndex: -1,
      disabled: isDisabled,
      name: name,
      size: state.collection.size,
      value: state.selectedKey,
      onChange: e => state.setSelectedKey(e.target.value)
    }, [...state.collection.getKeys()].map(key => {
      let item = state.collection.getItem(key);

      if (item.type === 'item') {
        return /*#__PURE__*/_react.createElement("option", {
          key: item.key,
          value: item.key
        }, item.textValue);
      }
    }))));
  } else if (name) {
    return /*#__PURE__*/_react.createElement("input", {
      type: "hidden",
      name: name,
      disabled: isDisabled,
      value: state.selectedKey
    });
  }

  return null;
}
//# sourceMappingURL=module.js.map
