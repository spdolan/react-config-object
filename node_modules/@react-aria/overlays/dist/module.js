import { VisuallyHidden } from "@react-aria/visually-hidden";
import _babelRuntimeHelpersEsmInteropRequireDefault from "@babel/runtime/helpers/esm/interopRequireDefault";
import _reactDom from "react-dom";
import { useId } from "@react-aria/utils";
import { useFocusWithin, useInteractOutside } from "@react-aria/interactions";
import { useLocale, useMessageFormatter } from "@react-aria/i18n";
import _react, { useCallback, useEffect, useState, useContext } from "react";
import _domHelpersOwnerDocument from "dom-helpers/ownerDocument";
import _domHelpersQueryScrollTop from "dom-helpers/query/scrollTop";
import _domHelpersQueryScrollLeft from "dom-helpers/query/scrollLeft";
import _domHelpersQueryPosition from "dom-helpers/query/position";
import _domHelpersQueryOffset from "dom-helpers/query/offset";
import _domHelpersStyle from "dom-helpers/style";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";
const $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
const $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE = {};

function $d45e305fb90d49e7c81f49bb4afe323b$var$getContainerDimensions(containerNode) {
  let width = 0,
      height = 0,
      top = 0,
      left = 0;
  let scroll = {};

  if (containerNode.tagName === 'BODY') {
    width = document.documentElement.clientWidth;
    height = document.documentElement.clientHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    ({
      width,
      height,
      top,
      left
    } = _domHelpersQueryOffset(containerNode));
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width,
    height,
    scroll,
    top,
    left
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(axis, offset, size, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let containerHeight = containerDimensions[$d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getMargins(node) {
  let style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement(input) {
  if ($d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input]) {
    return $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input];
  }

  let [placement, crossPlacement] = input.split(' ');
  let axis = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS[placement] || 'right';
  let crossAxis = $d45e305fb90d49e7c81f49bb4afe323b$var$CROSS_AXIS[axis];

  if (!$d45e305fb90d49e7c81f49bb4afe323b$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  let size = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[axis];
  let crossSize = $d45e305fb90d49e7c81f49bb4afe323b$var$AXIS_SIZE[crossAxis];
  $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  };
  return $d45e305fb90d49e7c81f49bb4afe323b$var$PARSED_PLACEMENT_CACHE[input];
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset) {
  let {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  } = placementInfo;
  let position = {};
  position[crossAxis] = childOffset[crossAxis] + crossOffset;

  if (crossPlacement === 'center') {
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  } // Ensure overlay sticks to target(ignore for overlays smaller than target)


  if (childOffset[crossSize] < overlaySize[crossSize]) {
    let positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);
    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);
  } // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.


  if (placement === axis) {
    position[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] = Math.floor(boundaryDimensions[size] - childOffset[axis] + offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top + containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding) : Math.max(0, childOffset.top - boundaryDimensions.top - boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - margins.top - margins.bottom - padding);
}

function $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let {
    placement,
    axis,
    size
  } = placementInfo;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {
  let placementInfo = $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement(placementInput);
  let {
    size,
    crossAxis,
    crossSize,
    placement,
    crossPlacement
  } = placementInfo;
  let position = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset);
  let normalizedOffset = offset;
  let space = $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    let flippedPlacementInfo = $d45e305fb90d49e7c81f49bb4afe323b$var$parsePlacement($d45e305fb90d49e7c81f49bb4afe323b$var$FLIPPED_DIRECTION[placement] + " " + crossPlacement);
    let flippedPosition = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset);
    let flippedSpace = $d45e305fb90d49e7c81f49bb4afe323b$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = -1 * offset;
    }
  }

  let delta = $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let maxHeight = $d45e305fb90d49e7c81f49bb4afe323b$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $d45e305fb90d49e7c81f49bb4afe323b$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);
  delta = $d45e305fb90d49e7c81f49bb4afe323b$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
/**
 * Determines where to place the overlay with regards to the target and the position of an optional indicator.
 */


function $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePosition(opts) {
  let {
    placement,
    targetNode,
    overlayNode,
    scrollNode,
    padding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset
  } = opts;
  let container = overlayNode.offsetParent || document.body;
  let isBodyContainer = container.tagName === 'BODY';
  let childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  let overlaySize = _domHelpersQueryOffset(overlayNode);

  let margins = $d45e305fb90d49e7c81f49bb4afe323b$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $d45e305fb90d49e7c81f49bb4afe323b$var$getScroll(scrollNode);
  let boundaryDimensions = $d45e305fb90d49e7c81f49bb4afe323b$var$getContainerDimensions(boundaryElement);
  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $d45e305fb90d49e7c81f49bb4afe323b$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);
}

/**
 * Handles positioning overlays like popovers and menus relative to a trigger
 * element, and updating the position when the window resizes.
 */
export function useOverlayPosition(props) {
  let {
    direction
  } = useLocale();
  let {
    targetRef,
    overlayRef,
    scrollRef = overlayRef,
    placement = 'bottom',
    containerPadding = 12,
    shouldFlip = true,
    boundaryElement = document.body,
    offset = 0,
    crossOffset = 0,
    shouldUpdatePosition = true,
    isOpen = true
  } = props;
  let [position, setPosition] = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  });
  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];
  let updatePosition = useCallback(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current) {
      return;
    }

    setPosition($d45e305fb90d49e7c81f49bb4afe323b$export$calculatePosition({
      placement: $ae841ee9d3f76b31663cf0594adb0fc$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset
    }));
  }, deps); // Update position when anything changes

  useEffect(updatePosition, deps); // Update position on window resize

  $ae841ee9d3f76b31663cf0594adb0fc$var$useResize(updatePosition);
  return {
    overlayProps: {
      style: _babelRuntimeHelpersEsmExtends({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    },
    updatePosition
  };
}

function $ae841ee9d3f76b31663cf0594adb0fc$var$useResize(onResize) {
  useEffect(() => {
    window.addEventListener('resize', onResize, false);
    return () => {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $ae841ee9d3f76b31663cf0594adb0fc$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

const $e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays = [];
/**
 * Provides the behavior for overlays such as dialogs, popovers, and menus.
 * Hides the overlay when the user interacts outside it, when the Escape key is pressed,
 * or optionally, on blur. Only the top-most overlay will close at once.
 */

export function useOverlay(props, ref) {
  let {
    onClose,
    shouldCloseOnBlur,
    isOpen,
    isDismissable = false
  } = props; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(() => {
    if (isOpen) {
      $e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays.push(ref);
    }

    return () => {
      let index = $e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays.indexOf(ref);

      if (index >= 0) {
        $e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  let onHide = () => {
    if ($e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays[$e4d5b842fe0e1058e95712442330b88c$var$visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  }; // Handle the escape key


  let onKeyDown = e => {
    if (e.key === 'Escape') {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref,
    onInteractOutside: isDismissable ? onHide : null
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: () => {
      onClose();
    }
  });
  return {
    overlayProps: _babelRuntimeHelpersEsmExtends({
      onKeyDown
    }, focusWithinProps)
  };
}

/**
 * Handles the behavior and accessibility for an overlay trigger, e.g. a button
 * that opens a popover, menu, or other overlay that is positioned relative to the trigger.
 */
export function useOverlayTrigger(props, state, ref) {
  let {
    type
  } = props;
  let {
    isOpen
  } = state; // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let onScroll = e => {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      let target = e.target;

      if (!ref.current || !target.contains(ref.current)) {
        return;
      }

      state.close();
    };

    window.addEventListener('scroll', onScroll, true);
    return () => {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, ref]); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often
  // announce it as a menu even for other values.

  let ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  let overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}

/**
 * Prevents scrolling on the document body on mount, and 
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */
export function usePreventScroll() {
  useEffect(() => {
    let overflow = document.body.style.overflow;
    let paddingRight = document.body.style.paddingRight;
    document.body.style.paddingRight = window.innerWidth - document.documentElement.clientWidth + 'px';
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = overflow;
      document.body.style.paddingRight = paddingRight;
    };
  }, []);
}

const $b876e5ac9c98db373bf726bce3d604e$var$Context = _react.createContext(null);
/**
 * Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
 * trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.
 * This is done recursively so that all parent providers are incremented and decremented.
 * If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
 * subtree from screen readers. This is done using React context in order to account for things
 * like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
 */


export function ModalProvider(props) {
  let {
    children
  } = props;
  let parent = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);
  let [modalCount, setModalCount] = useState(parent ? parent.modalCount : 0);
  let context = {
    parent,
    modalCount,

    addModal() {
      setModalCount(count => count + 1);

      if (parent) {
        parent.addModal();
      }
    },

    removeModal() {
      setModalCount(count => count - 1);

      if (parent) {
        parent.removeModal();
      }
    }

  };
  return /*#__PURE__*/_react.createElement($b876e5ac9c98db373bf726bce3d604e$var$Context.Provider, {
    value: context
  }, children);
}

/**
 * Used to determine if the tree should be aria-hidden based on how many
 * modals are open.
 */
export function useModalProvider() {
  let context = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}
/**
 * Creates a root node that will be aria-hidden if there are other modals open.
 */

function $b876e5ac9c98db373bf726bce3d604e$var$OverlayContainerDOM(props) {
  let {
    modalProviderProps
  } = useModalProvider();
  return /*#__PURE__*/_react.createElement("div", _babelRuntimeHelpersEsmExtends({}, props, modalProviderProps));
}
/**
 * An OverlayProvider acts as a container for the top-level application.
 * Any application that uses modal dialogs or other overlays should
 * be wrapped in a `<OverlayProvider>`. This is used to ensure that
 * the main content of the application is hidden from screen readers
 * if a modal or other overlay is opened. Only the top-most modal or
 * overlay should be accessible at once.
 */


export function OverlayProvider(props) {
  return /*#__PURE__*/_react.createElement(ModalProvider, null, /*#__PURE__*/_react.createElement($b876e5ac9c98db373bf726bce3d604e$var$OverlayContainerDOM, props));
}
/**
 * A container for overlays like modals and popovers. Renders the overlay
 * into a Portal which is placed at the end of the document body.
 * Also ensures that the overlay is hidden from screen readers if a
 * nested modal is opened. Only the top-most modal or overlay should
 * be accessible at once.
 */

export function OverlayContainer(props) {
  let contents = /*#__PURE__*/_react.createElement(OverlayProvider, props);

  return _reactDom.createPortal(contents, document.body);
}
/**
 * Hides content outside the current `<OverlayContainer>` from screen readers
 * on mount and restores it on unmount. Typically used by modal dialogs and
 * other types of overlays to ensure that only the top-most modal is
 * accessible at once.
 */

export function useModal() {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  let context = useContext($b876e5ac9c98db373bf726bce3d604e$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(() => {
    if (!context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return () => {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent]);
}
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ar-AE.json
var $e325a364098e05bf51160d06dcffdbe$exports = {};
$e325a364098e05bf51160d06dcffdbe$exports = JSON.parse("{\"dismiss\":\"تجاهل\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/bg-BG.json
var $ab088cc547d59c1be83369f8351a064$exports = {};
$ab088cc547d59c1be83369f8351a064$exports = JSON.parse("{\"dismiss\":\"Отхвърляне\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/cs-CZ.json
var $cec67ea16ca47059e10ca5e77187d8c2$exports = {};
$cec67ea16ca47059e10ca5e77187d8c2$exports = JSON.parse("{\"dismiss\":\"Odstranit\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/da-DK.json
var $d962fe1ed718c5ca37da1414136036f8$exports = {};
$d962fe1ed718c5ca37da1414136036f8$exports = JSON.parse("{\"dismiss\":\"Luk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/de-DE.json
var $c5167dda40dde69038848f007e5$exports = {};
$c5167dda40dde69038848f007e5$exports = JSON.parse("{\"dismiss\":\"Schließen\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/el-GR.json
var $ecdd1ac0020e47f58a9ed51b5fb$exports = {};
$ecdd1ac0020e47f58a9ed51b5fb$exports = JSON.parse("{\"dismiss\":\"Απόρριψη\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/en-US.json
var $f33e30a89f4dff807f90ebe8c$exports = {};
$f33e30a89f4dff807f90ebe8c$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/es-ES.json
var $ba353e2c61dcc5141af4537eeb3ef85c$exports = {};
$ba353e2c61dcc5141af4537eeb3ef85c$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/et-EE.json
var $dd3e8aaecbf1f2c2c0f9d51aacfd$exports = {};
$dd3e8aaecbf1f2c2c0f9d51aacfd$exports = JSON.parse("{\"dismiss\":\"Lõpeta\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fi-FI.json
var $f730aaed9f4652842b2a8f94a4a$exports = {};
$f730aaed9f4652842b2a8f94a4a$exports = JSON.parse("{\"dismiss\":\"Hylkää\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fr-FR.json
var $e76b22aab4e46b7806205b4af9ca3$exports = {};
$e76b22aab4e46b7806205b4af9ca3$exports = JSON.parse("{\"dismiss\":\"Rejeter\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/he-IL.json
var $c33ffdd5a9931bfc82c1c9b55e98de2f$exports = {};
$c33ffdd5a9931bfc82c1c9b55e98de2f$exports = JSON.parse("{\"dismiss\":\"התעלם\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hr-HR.json
var $d64cb70d4ce170f599f4df5adf4e9898$exports = {};
$d64cb70d4ce170f599f4df5adf4e9898$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hu-HU.json
var $c05270a6513a8b6d8a6552a35a162$exports = {};
$c05270a6513a8b6d8a6552a35a162$exports = JSON.parse("{\"dismiss\":\"Elutasítás\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/it-IT.json
var $df915df637af1f3c14c8376c69dfd$exports = {};
$df915df637af1f3c14c8376c69dfd$exports = JSON.parse("{\"dismiss\":\"Ignora\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ja-JP.json
var $e8bf1e6480d2c65d558c3537ec0d59ce$exports = {};
$e8bf1e6480d2c65d558c3537ec0d59ce$exports = JSON.parse("{\"dismiss\":\"閉じる\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ko-KR.json
var $e06e93e1c9472a7e2fc5b26a87ea7$exports = {};
$e06e93e1c9472a7e2fc5b26a87ea7$exports = JSON.parse("{\"dismiss\":\"무시\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lt-LT.json
var $fef82498418eab30c69349263b64e050$exports = {};
$fef82498418eab30c69349263b64e050$exports = JSON.parse("{\"dismiss\":\"Atmesti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lv-LV.json
var $c4df2502cb7b65c6578bcb8a165f6fc$exports = {};
$c4df2502cb7b65c6578bcb8a165f6fc$exports = JSON.parse("{\"dismiss\":\"Nerādīt\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nb-NO.json
var $b50f4e499c19f4d55113139bba$exports = {};
$b50f4e499c19f4d55113139bba$exports = JSON.parse("{\"dismiss\":\"Lukk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nl-NL.json
var $e45d2f0079f29e4f5c6469cca7c$exports = {};
$e45d2f0079f29e4f5c6469cca7c$exports = JSON.parse("{\"dismiss\":\"Negeren\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pl-PL.json
var $fcb5bfa87b2378a249bd7fb591ec22c2$exports = {};
$fcb5bfa87b2378a249bd7fb591ec22c2$exports = JSON.parse("{\"dismiss\":\"Zignoruj\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-BR.json
var $edae5c6f18c937cf0015f2aa266d9fea$exports = {};
$edae5c6f18c937cf0015f2aa266d9fea$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ro-RO.json
var $df1162b231d383d942e0fdb2bbf$exports = {};
$df1162b231d383d942e0fdb2bbf$exports = JSON.parse("{\"dismiss\":\"Revocare\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ru-RU.json
var $fa17537bfd201c57fa41fd31dbd9f074$exports = {};
$fa17537bfd201c57fa41fd31dbd9f074$exports = JSON.parse("{\"dismiss\":\"Пропустить\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sk-SK.json
var $c30db5bcff54a9e266ee7379a6cb8$exports = {};
$c30db5bcff54a9e266ee7379a6cb8$exports = JSON.parse("{\"dismiss\":\"Zrušiť\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sl-SI.json
var $c86d8cad7c0045ad51a1fea185411a61$exports = {};
$c86d8cad7c0045ad51a1fea185411a61$exports = JSON.parse("{\"dismiss\":\"Opusti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sr-SP.json
var $c610b0b50ebc0061e6c42c420a2e1be$exports = {};
$c610b0b50ebc0061e6c42c420a2e1be$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sv-SE.json
var $c298c5c92c55ce8d8289d8cc18ea512$exports = {};
$c298c5c92c55ce8d8289d8cc18ea512$exports = JSON.parse("{\"dismiss\":\"Avvisa\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/tr-TR.json
var $f438196d9674b9d180ea6e74d7$exports = {};
$f438196d9674b9d180ea6e74d7$exports = JSON.parse("{\"dismiss\":\"Kapat\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/uk-UA.json
var $fa842ebaf07187d5bc74e0fa6c4679b$exports = {};
$fa842ebaf07187d5bc74e0fa6c4679b$exports = JSON.parse("{\"dismiss\":\"Скасувати\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-CN.json
var $cdcbe39f22ae1814551e7f30dcfc8$exports = {};
$cdcbe39f22ae1814551e7f30dcfc8$exports = JSON.parse("{\"dismiss\":\"取消\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-TW.json
var $a8c729d90cde82a4eb34bebfb46a6$exports = {};
$a8c729d90cde82a4eb34bebfb46a6$exports = JSON.parse("{\"dismiss\":\"關閉\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
const $c94f95b3263b356bb2e58a3832a84$var$intlMessages = {
  "ar-AE": _babelRuntimeHelpersEsmInteropRequireDefault($e325a364098e05bf51160d06dcffdbe$exports).default,
  "bg-BG": _babelRuntimeHelpersEsmInteropRequireDefault($ab088cc547d59c1be83369f8351a064$exports).default,
  "cs-CZ": _babelRuntimeHelpersEsmInteropRequireDefault($cec67ea16ca47059e10ca5e77187d8c2$exports).default,
  "da-DK": _babelRuntimeHelpersEsmInteropRequireDefault($d962fe1ed718c5ca37da1414136036f8$exports).default,
  "de-DE": _babelRuntimeHelpersEsmInteropRequireDefault($c5167dda40dde69038848f007e5$exports).default,
  "el-GR": _babelRuntimeHelpersEsmInteropRequireDefault($ecdd1ac0020e47f58a9ed51b5fb$exports).default,
  "en-US": _babelRuntimeHelpersEsmInteropRequireDefault($f33e30a89f4dff807f90ebe8c$exports).default,
  "es-ES": _babelRuntimeHelpersEsmInteropRequireDefault($ba353e2c61dcc5141af4537eeb3ef85c$exports).default,
  "et-EE": _babelRuntimeHelpersEsmInteropRequireDefault($dd3e8aaecbf1f2c2c0f9d51aacfd$exports).default,
  "fi-FI": _babelRuntimeHelpersEsmInteropRequireDefault($f730aaed9f4652842b2a8f94a4a$exports).default,
  "fr-FR": _babelRuntimeHelpersEsmInteropRequireDefault($e76b22aab4e46b7806205b4af9ca3$exports).default,
  "he-IL": _babelRuntimeHelpersEsmInteropRequireDefault($c33ffdd5a9931bfc82c1c9b55e98de2f$exports).default,
  "hr-HR": _babelRuntimeHelpersEsmInteropRequireDefault($d64cb70d4ce170f599f4df5adf4e9898$exports).default,
  "hu-HU": _babelRuntimeHelpersEsmInteropRequireDefault($c05270a6513a8b6d8a6552a35a162$exports).default,
  "it-IT": _babelRuntimeHelpersEsmInteropRequireDefault($df915df637af1f3c14c8376c69dfd$exports).default,
  "ja-JP": _babelRuntimeHelpersEsmInteropRequireDefault($e8bf1e6480d2c65d558c3537ec0d59ce$exports).default,
  "ko-KR": _babelRuntimeHelpersEsmInteropRequireDefault($e06e93e1c9472a7e2fc5b26a87ea7$exports).default,
  "lt-LT": _babelRuntimeHelpersEsmInteropRequireDefault($fef82498418eab30c69349263b64e050$exports).default,
  "lv-LV": _babelRuntimeHelpersEsmInteropRequireDefault($c4df2502cb7b65c6578bcb8a165f6fc$exports).default,
  "nb-NO": _babelRuntimeHelpersEsmInteropRequireDefault($b50f4e499c19f4d55113139bba$exports).default,
  "nl-NL": _babelRuntimeHelpersEsmInteropRequireDefault($e45d2f0079f29e4f5c6469cca7c$exports).default,
  "pl-PL": _babelRuntimeHelpersEsmInteropRequireDefault($fcb5bfa87b2378a249bd7fb591ec22c2$exports).default,
  "pt-BR": _babelRuntimeHelpersEsmInteropRequireDefault($edae5c6f18c937cf0015f2aa266d9fea$exports).default,
  "ro-RO": _babelRuntimeHelpersEsmInteropRequireDefault($df1162b231d383d942e0fdb2bbf$exports).default,
  "ru-RU": _babelRuntimeHelpersEsmInteropRequireDefault($fa17537bfd201c57fa41fd31dbd9f074$exports).default,
  "sk-SK": _babelRuntimeHelpersEsmInteropRequireDefault($c30db5bcff54a9e266ee7379a6cb8$exports).default,
  "sl-SI": _babelRuntimeHelpersEsmInteropRequireDefault($c86d8cad7c0045ad51a1fea185411a61$exports).default,
  "sr-SP": _babelRuntimeHelpersEsmInteropRequireDefault($c610b0b50ebc0061e6c42c420a2e1be$exports).default,
  "sv-SE": _babelRuntimeHelpersEsmInteropRequireDefault($c298c5c92c55ce8d8289d8cc18ea512$exports).default,
  "tr-TR": _babelRuntimeHelpersEsmInteropRequireDefault($f438196d9674b9d180ea6e74d7$exports).default,
  "uk-UA": _babelRuntimeHelpersEsmInteropRequireDefault($fa842ebaf07187d5bc74e0fa6c4679b$exports).default,
  "zh-CN": _babelRuntimeHelpersEsmInteropRequireDefault($cdcbe39f22ae1814551e7f30dcfc8$exports).default,
  "zh-TW": _babelRuntimeHelpersEsmInteropRequireDefault($a8c729d90cde82a4eb34bebfb46a6$exports).default
};

/**
 * A visually hidden button that can be used to allow screen reader
 * users to dismiss a modal or popup when there is no visual
 * affordance to do so.
 */
export function DismissButton(props) {
  let {
    onDismiss
  } = props;
  let formatMessage = useMessageFormatter($c94f95b3263b356bb2e58a3832a84$var$intlMessages);

  let onClick = () => {
    if (onDismiss) {
      onDismiss();
    }
  };

  return /*#__PURE__*/_react.createElement(VisuallyHidden, null, /*#__PURE__*/_react.createElement("button", {
    tabIndex: -1,
    "aria-label": formatMessage('dismiss'),
    onClick: onClick
  }));
}
//# sourceMappingURL=module.js.map
