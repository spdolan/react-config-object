var {
  VisuallyHidden
} = require("@react-aria/visually-hidden");

var _babelRuntimeHelpersInteropRequireDefault = $parcel$interopDefault(require("@babel/runtime/helpers/interopRequireDefault"));

var _reactDom = $parcel$interopDefault(require("react-dom"));

var {
  useId
} = require("@react-aria/utils");

var {
  useFocusWithin,
  useInteractOutside
} = require("@react-aria/interactions");

var {
  useLocale,
  useMessageFormatter
} = require("@react-aria/i18n");

var _react2 = require("react");

var _react = $parcel$interopDefault(_react2);

var {
  useCallback,
  useEffect,
  useState,
  useContext
} = _react2;

var _domHelpersOwnerDocument = $parcel$interopDefault(require("dom-helpers/ownerDocument"));

var _domHelpersQueryScrollTop = $parcel$interopDefault(require("dom-helpers/query/scrollTop"));

var _domHelpersQueryScrollLeft = $parcel$interopDefault(require("dom-helpers/query/scrollLeft"));

var _domHelpersQueryPosition = $parcel$interopDefault(require("dom-helpers/query/position"));

var _domHelpersQueryOffset = $parcel$interopDefault(require("dom-helpers/query/offset"));

var _domHelpersStyle = $parcel$interopDefault(require("dom-helpers/style"));

var _babelRuntimeHelpersExtends = $parcel$interopDefault(require("@babel/runtime/helpers/extends"));

function $parcel$interopDefault(a) {
  return a && a.__esModule ? a.default : a;
}

const $c13020473a0fe27b1a1c4797269d1704$var$AXIS = {
  top: 'top',
  bottom: 'top',
  left: 'left',
  right: 'left'
};
const $c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION = {
  top: 'bottom',
  bottom: 'top',
  left: 'right',
  right: 'left'
};
const $c13020473a0fe27b1a1c4797269d1704$var$CROSS_AXIS = {
  top: 'left',
  left: 'top'
};
const $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE = {
  top: 'height',
  left: 'width'
};
const $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE = {};

function $c13020473a0fe27b1a1c4797269d1704$var$getContainerDimensions(containerNode) {
  let width = 0,
      height = 0,
      top = 0,
      left = 0;
  let scroll = {};

  if (containerNode.tagName === 'BODY') {
    width = document.documentElement.clientWidth;
    height = document.documentElement.clientHeight;
    scroll.top = _domHelpersQueryScrollTop(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(_domHelpersOwnerDocument(containerNode).documentElement) || _domHelpersQueryScrollLeft(containerNode);
  } else {
    ({
      width,
      height,
      top,
      left
    } = _domHelpersQueryOffset(containerNode));
    scroll.top = _domHelpersQueryScrollTop(containerNode);
    scroll.left = _domHelpersQueryScrollLeft(containerNode);
  }

  return {
    width,
    height,
    scroll,
    top,
    left
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$getScroll(node) {
  return {
    top: node.scrollTop,
    left: node.scrollLeft,
    width: node.scrollWidth,
    height: node.scrollHeight
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$getDelta(axis, offset, size, containerDimensions, padding) {
  let containerScroll = containerDimensions.scroll[axis];
  let containerHeight = containerDimensions[$c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[axis]];
  let startEdgeOffset = offset - padding - containerScroll;
  let endEdgeOffset = offset + padding - containerScroll + size;

  if (startEdgeOffset < 0) {
    return -startEdgeOffset;
  } else if (endEdgeOffset > containerHeight) {
    return Math.max(containerHeight - endEdgeOffset, -startEdgeOffset);
  } else {
    return 0;
  }
}

function $c13020473a0fe27b1a1c4797269d1704$var$getMargins(node) {
  let style = window.getComputedStyle(node);
  return {
    top: parseInt(style.marginTop, 10) || 0,
    bottom: parseInt(style.marginBottom, 10) || 0,
    left: parseInt(style.marginLeft, 10) || 0,
    right: parseInt(style.marginRight, 10) || 0
  };
}

function $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement(input) {
  if ($c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input]) {
    return $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input];
  }

  let [placement, crossPlacement] = input.split(' ');
  let axis = $c13020473a0fe27b1a1c4797269d1704$var$AXIS[placement] || 'right';
  let crossAxis = $c13020473a0fe27b1a1c4797269d1704$var$CROSS_AXIS[axis];

  if (!$c13020473a0fe27b1a1c4797269d1704$var$AXIS[crossPlacement]) {
    crossPlacement = 'center';
  }

  let size = $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[axis];
  let crossSize = $c13020473a0fe27b1a1c4797269d1704$var$AXIS_SIZE[crossAxis];
  $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input] = {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  };
  return $c13020473a0fe27b1a1c4797269d1704$var$PARSED_PLACEMENT_CACHE[input];
}

function $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset) {
  let {
    placement,
    crossPlacement,
    axis,
    crossAxis,
    size,
    crossSize
  } = placementInfo;
  let position = {};
  position[crossAxis] = childOffset[crossAxis] + crossOffset;

  if (crossPlacement === 'center') {
    position[crossAxis] += (childOffset[crossSize] - overlaySize[crossSize]) / 2;
  } else if (crossPlacement !== crossAxis) {
    position[crossAxis] += childOffset[crossSize] - overlaySize[crossSize];
  } // Ensure overlay sticks to target(ignore for overlays smaller than target)


  if (childOffset[crossSize] < overlaySize[crossSize]) {
    let positionForPositiveSideOverflow = Math.min(position[crossAxis], childOffset[crossAxis]);
    position[crossAxis] = Math.max(positionForPositiveSideOverflow, childOffset[crossAxis] - overlaySize[crossSize] + childOffset[crossSize]);
  } // Floor these so the position isn't placed on a partial pixel, only whole pixels. Shouldn't matter if it was floored or ceiled, so chose one.


  if (placement === axis) {
    position[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] = Math.floor(boundaryDimensions[size] - childOffset[axis] + offset);
  } else {
    position[axis] = Math.floor(childOffset[axis] + childOffset[size] + offset);
  }

  return position;
}

function $c13020473a0fe27b1a1c4797269d1704$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding) {
  return position.top != null ? Math.max(0, boundaryDimensions.height + boundaryDimensions.top + boundaryDimensions.scroll.top + containerOffsetWithBoundary.top - position.top - margins.top - margins.bottom - padding) : Math.max(0, childOffset.top - boundaryDimensions.top - boundaryDimensions.scroll.top - containerOffsetWithBoundary.top - margins.top - margins.bottom - padding);
}

function $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding, placementInfo) {
  let {
    placement,
    axis,
    size
  } = placementInfo;

  if (placement === axis) {
    return Math.max(0, childOffset[axis] - boundaryDimensions[axis] - boundaryDimensions.scroll[axis] + containerOffsetWithBoundary[axis] - margins[axis] - margins[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] - padding);
  }

  return Math.max(0, boundaryDimensions[size] + boundaryDimensions[axis] + boundaryDimensions.scroll[axis] - containerOffsetWithBoundary[axis] - childOffset[axis] - childOffset[size] - margins[axis] - margins[$c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[axis]] - padding);
}

function $c13020473a0fe27b1a1c4797269d1704$export$calculatePositionInternal(placementInput, childOffset, overlaySize, scrollSize, margins, padding, flip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset) {
  let placementInfo = $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement(placementInput);
  let {
    size,
    crossAxis,
    crossSize,
    placement,
    crossPlacement
  } = placementInfo;
  let position = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, offset, crossOffset);
  let normalizedOffset = offset;
  let space = $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, placementInfo); // Check if the scroll size of the overlay is greater than the available space to determine if we need to flip

  if (flip && scrollSize[size] > space) {
    let flippedPlacementInfo = $c13020473a0fe27b1a1c4797269d1704$var$parsePlacement($c13020473a0fe27b1a1c4797269d1704$var$FLIPPED_DIRECTION[placement] + " " + crossPlacement);
    let flippedPosition = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, flippedPlacementInfo, -1 * offset, crossOffset);
    let flippedSpace = $c13020473a0fe27b1a1c4797269d1704$var$getAvailableSpace(boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding + offset, flippedPlacementInfo); // If the available space for the flipped position is greater than the original available space, flip.

    if (flippedSpace > space) {
      placementInfo = flippedPlacementInfo;
      position = flippedPosition;
      normalizedOffset = -1 * offset;
    }
  }

  let delta = $c13020473a0fe27b1a1c4797269d1704$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let maxHeight = $c13020473a0fe27b1a1c4797269d1704$var$getMaxHeight(position, boundaryDimensions, containerOffsetWithBoundary, childOffset, margins, padding);
  overlaySize.height = Math.min(overlaySize.height, maxHeight);
  position = $c13020473a0fe27b1a1c4797269d1704$var$computePosition(childOffset, boundaryDimensions, overlaySize, placementInfo, normalizedOffset, crossOffset);
  delta = $c13020473a0fe27b1a1c4797269d1704$var$getDelta(crossAxis, position[crossAxis], overlaySize[crossSize], boundaryDimensions, padding);
  position[crossAxis] += delta;
  let arrowPosition = {};
  arrowPosition[crossAxis] = childOffset[crossSize] > overlaySize[crossSize] ? null : childOffset[crossAxis] - position[crossAxis] + childOffset[crossSize] / 2;
  return {
    position,
    maxHeight: maxHeight,
    arrowOffsetLeft: arrowPosition.left,
    arrowOffsetTop: arrowPosition.top,
    placement: placementInfo.placement
  };
}
/**
 * Determines where to place the overlay with regards to the target and the position of an optional indicator.
 */


function $c13020473a0fe27b1a1c4797269d1704$export$calculatePosition(opts) {
  let {
    placement,
    targetNode,
    overlayNode,
    scrollNode,
    padding,
    shouldFlip,
    boundaryElement,
    offset,
    crossOffset
  } = opts;
  let container = overlayNode.offsetParent || document.body;
  let isBodyContainer = container.tagName === 'BODY';
  let childOffset = isBodyContainer ? _domHelpersQueryOffset(targetNode) : _domHelpersQueryPosition(targetNode, container);

  if (!isBodyContainer) {
    childOffset.top += parseInt(_domHelpersStyle(targetNode, 'marginTop'), 10) || 0;
    childOffset.left += parseInt(_domHelpersStyle(targetNode, 'marginLeft'), 10) || 0;
  }

  let overlaySize = _domHelpersQueryOffset(overlayNode);

  let margins = $c13020473a0fe27b1a1c4797269d1704$var$getMargins(overlayNode);
  overlaySize.width += margins.left + margins.right;
  overlaySize.height += margins.top + margins.bottom;
  let scrollSize = $c13020473a0fe27b1a1c4797269d1704$var$getScroll(scrollNode);
  let boundaryDimensions = $c13020473a0fe27b1a1c4797269d1704$var$getContainerDimensions(boundaryElement);
  let containerOffsetWithBoundary = boundaryElement.tagName === 'BODY' ? _domHelpersQueryOffset(container) : _domHelpersQueryPosition(container, boundaryElement);
  return $c13020473a0fe27b1a1c4797269d1704$export$calculatePositionInternal(placement, childOffset, overlaySize, scrollSize, margins, padding, shouldFlip, boundaryDimensions, containerOffsetWithBoundary, offset, crossOffset);
}

/**
 * Handles positioning overlays like popovers and menus relative to a trigger
 * element, and updating the position when the window resizes.
 */
function useOverlayPosition(props) {
  let {
    direction
  } = useLocale();
  let {
    targetRef,
    overlayRef,
    scrollRef = overlayRef,
    placement = 'bottom',
    containerPadding = 12,
    shouldFlip = true,
    boundaryElement = document.body,
    offset = 0,
    crossOffset = 0,
    shouldUpdatePosition = true,
    isOpen = true
  } = props;
  let [position, setPosition] = useState({
    position: {},
    arrowOffsetLeft: undefined,
    arrowOffsetTop: undefined,
    maxHeight: undefined,
    placement: undefined
  });
  let deps = [shouldUpdatePosition, placement, overlayRef.current, targetRef.current, scrollRef.current, containerPadding, shouldFlip, boundaryElement, offset, crossOffset, isOpen, direction];
  let updatePosition = useCallback(() => {
    if (shouldUpdatePosition === false || !isOpen || !overlayRef.current || !targetRef.current || !scrollRef.current) {
      return;
    }

    setPosition($c13020473a0fe27b1a1c4797269d1704$export$calculatePosition({
      placement: $adfbd034e9bc71c1$var$translateRTL(placement, direction),
      overlayNode: overlayRef.current,
      targetNode: targetRef.current,
      scrollNode: scrollRef.current,
      padding: containerPadding,
      shouldFlip,
      boundaryElement,
      offset,
      crossOffset
    }));
  }, deps); // Update position when anything changes

  useEffect(updatePosition, deps); // Update position on window resize

  $adfbd034e9bc71c1$var$useResize(updatePosition);
  return {
    overlayProps: {
      style: _babelRuntimeHelpersExtends({
        position: 'absolute',
        zIndex: 100000
      }, position.position, {
        maxHeight: position.maxHeight
      })
    },
    placement: position.placement,
    arrowProps: {
      style: {
        left: position.arrowOffsetLeft,
        top: position.arrowOffsetTop
      }
    },
    updatePosition
  };
}

exports.useOverlayPosition = useOverlayPosition;

function $adfbd034e9bc71c1$var$useResize(onResize) {
  useEffect(() => {
    window.addEventListener('resize', onResize, false);
    return () => {
      window.removeEventListener('resize', onResize, false);
    };
  }, [onResize]);
}

function $adfbd034e9bc71c1$var$translateRTL(position, direction) {
  if (direction === 'rtl') {
    return position.replace('start', 'right').replace('end', 'left');
  }

  return position.replace('start', 'left').replace('end', 'right');
}

const $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays = [];
/**
 * Provides the behavior for overlays such as dialogs, popovers, and menus.
 * Hides the overlay when the user interacts outside it, when the Escape key is pressed,
 * or optionally, on blur. Only the top-most overlay will close at once.
 */

function useOverlay(props, ref) {
  let {
    onClose,
    shouldCloseOnBlur,
    isOpen,
    isDismissable = false
  } = props; // Add the overlay ref to the stack of visible overlays on mount, and remove on unmount.

  useEffect(() => {
    if (isOpen) {
      $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.push(ref);
    }

    return () => {
      let index = $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.indexOf(ref);

      if (index >= 0) {
        $a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.splice(index, 1);
      }
    };
  }, [isOpen, ref]); // Only hide the overlay when it is the topmost visible overlay in the stack.

  let onHide = () => {
    if ($a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays[$a59c58b6dadb0208d379e9464d2377f7$var$visibleOverlays.length - 1] === ref && onClose) {
      onClose();
    }
  }; // Handle the escape key


  let onKeyDown = e => {
    if (e.key === 'Escape') {
      e.preventDefault();
      onHide();
    }
  }; // Handle clicking outside the overlay to close it


  useInteractOutside({
    ref,
    onInteractOutside: isDismissable ? onHide : null
  });
  let {
    focusWithinProps
  } = useFocusWithin({
    isDisabled: !shouldCloseOnBlur,
    onBlurWithin: () => {
      onClose();
    }
  });
  return {
    overlayProps: _babelRuntimeHelpersExtends({
      onKeyDown
    }, focusWithinProps)
  };
}

exports.useOverlay = useOverlay;

/**
 * Handles the behavior and accessibility for an overlay trigger, e.g. a button
 * that opens a popover, menu, or other overlay that is positioned relative to the trigger.
 */
function useOverlayTrigger(props, state, ref) {
  let {
    type
  } = props;
  let {
    isOpen
  } = state; // When scrolling a parent scrollable region of the trigger (other than the body),
  // we hide the popover. Otherwise, its position would be incorrect.

  useEffect(() => {
    if (!isOpen) {
      return;
    }

    let onScroll = e => {
      // Ignore if scrolling an scrollable region outside the trigger's tree.
      let target = e.target;

      if (!ref.current || !target.contains(ref.current)) {
        return;
      }

      state.close();
    };

    window.addEventListener('scroll', onScroll, true);
    return () => {
      window.removeEventListener('scroll', onScroll, true);
    };
  }, [isOpen, ref]); // Aria 1.1 supports multiple values for aria-haspopup other than just menus.
  // https://www.w3.org/TR/wai-aria-1.1/#aria-haspopup
  // However, we only add it for menus for now because screen readers often
  // announce it as a menu even for other values.

  let ariaHasPopup = undefined;

  if (type === 'menu') {
    ariaHasPopup = true;
  } else if (type === 'listbox') {
    ariaHasPopup = 'listbox';
  }

  let overlayId = useId();
  return {
    triggerProps: {
      'aria-haspopup': ariaHasPopup,
      'aria-expanded': isOpen,
      'aria-controls': isOpen ? overlayId : null
    },
    overlayProps: {
      id: overlayId
    }
  };
}

exports.useOverlayTrigger = useOverlayTrigger;

/**
 * Prevents scrolling on the document body on mount, and 
 * restores it on unmount. Also ensures that content does not
 * shift due to the scrollbars disappearing.
 */
function usePreventScroll() {
  useEffect(() => {
    let overflow = document.body.style.overflow;
    let paddingRight = document.body.style.paddingRight;
    document.body.style.paddingRight = window.innerWidth - document.documentElement.clientWidth + 'px';
    document.body.style.overflow = 'hidden';
    return () => {
      document.body.style.overflow = overflow;
      document.body.style.paddingRight = paddingRight;
    };
  }, []);
}

exports.usePreventScroll = usePreventScroll;

const $c5f9596976ab8bd94c5879001549a3e$var$Context = _react.createContext(null);
/**
 * Each ModalProvider tracks how many modals are open in its subtree. On mount, the modals
 * trigger `addModal` to increment the count, and trigger `removeModal` on unmount to decrement it.
 * This is done recursively so that all parent providers are incremented and decremented.
 * If the modal count is greater than zero, we add `aria-hidden` to this provider to hide its
 * subtree from screen readers. This is done using React context in order to account for things
 * like portals, which can cause the React tree and the DOM tree to differ significantly in structure.
 */


function ModalProvider(props) {
  let {
    children
  } = props;
  let parent = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);
  let [modalCount, setModalCount] = useState(parent ? parent.modalCount : 0);
  let context = {
    parent,
    modalCount,

    addModal() {
      setModalCount(count => count + 1);

      if (parent) {
        parent.addModal();
      }
    },

    removeModal() {
      setModalCount(count => count - 1);

      if (parent) {
        parent.removeModal();
      }
    }

  };
  return /*#__PURE__*/_react.createElement($c5f9596976ab8bd94c5879001549a3e$var$Context.Provider, {
    value: context
  }, children);
}

exports.ModalProvider = ModalProvider;

/**
 * Used to determine if the tree should be aria-hidden based on how many
 * modals are open.
 */
function useModalProvider() {
  let context = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);
  return {
    modalProviderProps: {
      'aria-hidden': context && context.modalCount > 0 ? true : null
    }
  };
}
/**
 * Creates a root node that will be aria-hidden if there are other modals open.
 */


exports.useModalProvider = useModalProvider;

function $c5f9596976ab8bd94c5879001549a3e$var$OverlayContainerDOM(props) {
  let {
    modalProviderProps
  } = useModalProvider();
  return /*#__PURE__*/_react.createElement("div", _babelRuntimeHelpersExtends({}, props, modalProviderProps));
}
/**
 * An OverlayProvider acts as a container for the top-level application.
 * Any application that uses modal dialogs or other overlays should
 * be wrapped in a `<OverlayProvider>`. This is used to ensure that
 * the main content of the application is hidden from screen readers
 * if a modal or other overlay is opened. Only the top-most modal or
 * overlay should be accessible at once.
 */


function OverlayProvider(props) {
  return /*#__PURE__*/_react.createElement(ModalProvider, null, /*#__PURE__*/_react.createElement($c5f9596976ab8bd94c5879001549a3e$var$OverlayContainerDOM, props));
}
/**
 * A container for overlays like modals and popovers. Renders the overlay
 * into a Portal which is placed at the end of the document body.
 * Also ensures that the overlay is hidden from screen readers if a
 * nested modal is opened. Only the top-most modal or overlay should
 * be accessible at once.
 */


exports.OverlayProvider = OverlayProvider;

function OverlayContainer(props) {
  let contents = /*#__PURE__*/_react.createElement(OverlayProvider, props);

  return _reactDom.createPortal(contents, document.body);
}
/**
 * Hides content outside the current `<OverlayContainer>` from screen readers
 * on mount and restores it on unmount. Typically used by modal dialogs and
 * other types of overlays to ensure that only the top-most modal is
 * accessible at once.
 */


exports.OverlayContainer = OverlayContainer;

function useModal() {
  // Add aria-hidden to all parent providers on mount, and restore on unmount.
  let context = useContext($c5f9596976ab8bd94c5879001549a3e$var$Context);

  if (!context) {
    throw new Error('Modal is not contained within a provider');
  }

  useEffect(() => {
    if (!context || !context.parent) {
      return;
    } // The immediate context is from the provider containing this modal, so we only
    // want to trigger aria-hidden on its parents not on the modal provider itself.


    context.parent.addModal();
    return () => {
      if (context && context.parent) {
        context.parent.removeModal();
      }
    };
  }, [context, context.parent]);
}

exports.useModal = useModal;
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ar-AE.json
var $a8bb21dadcfaad10bb0a0bcf2b281764$exports = {};
$a8bb21dadcfaad10bb0a0bcf2b281764$exports = JSON.parse("{\"dismiss\":\"تجاهل\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/bg-BG.json
var $dafefe57ee4fa5270277199b63666456$exports = {};
$dafefe57ee4fa5270277199b63666456$exports = JSON.parse("{\"dismiss\":\"Отхвърляне\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/cs-CZ.json
var $c2158ac3aac63d05c0787f91c5e6$exports = {};
$c2158ac3aac63d05c0787f91c5e6$exports = JSON.parse("{\"dismiss\":\"Odstranit\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/da-DK.json
var $f7aea96abdaae1eb301c63fe67ff9fa$exports = {};
$f7aea96abdaae1eb301c63fe67ff9fa$exports = JSON.parse("{\"dismiss\":\"Luk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/de-DE.json
var $f3491c664171e6b5e47db3baca390e$exports = {};
$f3491c664171e6b5e47db3baca390e$exports = JSON.parse("{\"dismiss\":\"Schließen\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/el-GR.json
var $da631def8a53d3d7ca63b5a989a2$exports = {};
$da631def8a53d3d7ca63b5a989a2$exports = JSON.parse("{\"dismiss\":\"Απόρριψη\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/en-US.json
var $fb4c477a38a74b935d35db24ae7$exports = {};
$fb4c477a38a74b935d35db24ae7$exports = JSON.parse("{\"dismiss\":\"Dismiss\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/es-ES.json
var $b6fd69f9d5c0d1736b0ffb60159dbd4$exports = {};
$b6fd69f9d5c0d1736b0ffb60159dbd4$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/et-EE.json
var $ba5713ed42715892c62c91f4a61185db$exports = {};
$ba5713ed42715892c62c91f4a61185db$exports = JSON.parse("{\"dismiss\":\"Lõpeta\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fi-FI.json
var $d425c7f620a7cd6fec958b2d805b4748$exports = {};
$d425c7f620a7cd6fec958b2d805b4748$exports = JSON.parse("{\"dismiss\":\"Hylkää\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/fr-FR.json
var $a53b9b9e4ee3c32689ca1c9d37$exports = {};
$a53b9b9e4ee3c32689ca1c9d37$exports = JSON.parse("{\"dismiss\":\"Rejeter\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/he-IL.json
var $c53806192c6b46eb32dc82efae908cb$exports = {};
$c53806192c6b46eb32dc82efae908cb$exports = JSON.parse("{\"dismiss\":\"התעלם\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hr-HR.json
var $cbbca9d8ba35e50d9d74ddc492ac95d5$exports = {};
$cbbca9d8ba35e50d9d74ddc492ac95d5$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/hu-HU.json
var $b6e1f06770a0ad8a02049cb304d$exports = {};
$b6e1f06770a0ad8a02049cb304d$exports = JSON.parse("{\"dismiss\":\"Elutasítás\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/it-IT.json
var $b6c1d31d04e4e80df25d89ebefb38d6c$exports = {};
$b6c1d31d04e4e80df25d89ebefb38d6c$exports = JSON.parse("{\"dismiss\":\"Ignora\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ja-JP.json
var $a858c6dc87cf51add44cd600186b$exports = {};
$a858c6dc87cf51add44cd600186b$exports = JSON.parse("{\"dismiss\":\"閉じる\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ko-KR.json
var $bce3a6596f5d6bce7af4e1cdfe714b9$exports = {};
$bce3a6596f5d6bce7af4e1cdfe714b9$exports = JSON.parse("{\"dismiss\":\"무시\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lt-LT.json
var $a80424d4da258b90efdca51671420e98$exports = {};
$a80424d4da258b90efdca51671420e98$exports = JSON.parse("{\"dismiss\":\"Atmesti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/lv-LV.json
var $b7b9bc8c0cfc6eec9fa971e7b25cd656$exports = {};
$b7b9bc8c0cfc6eec9fa971e7b25cd656$exports = JSON.parse("{\"dismiss\":\"Nerādīt\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nb-NO.json
var $e985758bae9fabb24500c21a0a00b725$exports = {};
$e985758bae9fabb24500c21a0a00b725$exports = JSON.parse("{\"dismiss\":\"Lukk\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/nl-NL.json
var $f05d419963f6daeda3bc9dbbe3cc02bd$exports = {};
$f05d419963f6daeda3bc9dbbe3cc02bd$exports = JSON.parse("{\"dismiss\":\"Negeren\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pl-PL.json
var $c8fa3e85daf6d04ed07583e629c87ce4$exports = {};
$c8fa3e85daf6d04ed07583e629c87ce4$exports = JSON.parse("{\"dismiss\":\"Zignoruj\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/pt-BR.json
var $f06e8ad24001ed35ea808810226a15$exports = {};
$f06e8ad24001ed35ea808810226a15$exports = JSON.parse("{\"dismiss\":\"Descartar\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ro-RO.json
var $a20ad400f1086b2bea7f9791d7257ad$exports = {};
$a20ad400f1086b2bea7f9791d7257ad$exports = JSON.parse("{\"dismiss\":\"Revocare\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/ru-RU.json
var $fc28441a9133071c2297a09b6b420dd$exports = {};
$fc28441a9133071c2297a09b6b420dd$exports = JSON.parse("{\"dismiss\":\"Пропустить\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sk-SK.json
var $a91ecad4479ad50b50aa177a2506dc$exports = {};
$a91ecad4479ad50b50aa177a2506dc$exports = JSON.parse("{\"dismiss\":\"Zrušiť\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sl-SI.json
var $f9693ead50748c9beb107ad23956eb9$exports = {};
$f9693ead50748c9beb107ad23956eb9$exports = JSON.parse("{\"dismiss\":\"Opusti\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sr-SP.json
var $b5e22101ce830f7d95581df69464b$exports = {};
$b5e22101ce830f7d95581df69464b$exports = JSON.parse("{\"dismiss\":\"Odbaci\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/sv-SE.json
var $c0b006e739315f2d0109fd704d505d4d$exports = {};
$c0b006e739315f2d0109fd704d505d4d$exports = JSON.parse("{\"dismiss\":\"Avvisa\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/tr-TR.json
var $b2fcb8208d40a3677791cb274f5c23$exports = {};
$b2fcb8208d40a3677791cb274f5c23$exports = JSON.parse("{\"dismiss\":\"Kapat\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/uk-UA.json
var $bedf08a338a4a9658a5b3265b7ba64$exports = {};
$bedf08a338a4a9658a5b3265b7ba64$exports = JSON.parse("{\"dismiss\":\"Скасувати\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-CN.json
var $b49f1939211bfd9e1f4f626061efad44$exports = {};
$b49f1939211bfd9e1f4f626061efad44$exports = JSON.parse("{\"dismiss\":\"取消\"}");
// ASSET: /Users/govett/dev/react-spectrum-v3/packages/@react-aria/overlays/intl/zh-TW.json
var $a878720d2a5fd83cfd5a0f74b64957e$exports = {};
$a878720d2a5fd83cfd5a0f74b64957e$exports = JSON.parse("{\"dismiss\":\"關閉\"}");

/*
 * Copyright 2020 Adobe. All rights reserved.
 * This file is licensed to you under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License. You may obtain a copy
 * of the License at http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software distributed under
 * the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR REPRESENTATIONS
 * OF ANY KIND, either express or implied. See the License for the specific language
 * governing permissions and limitations under the License.
 */
// @ts-ignore
const $e0a65de2c0deb9a27bf483be129a43c1$var$intlMessages = {
  "ar-AE": _babelRuntimeHelpersInteropRequireDefault($a8bb21dadcfaad10bb0a0bcf2b281764$exports).default,
  "bg-BG": _babelRuntimeHelpersInteropRequireDefault($dafefe57ee4fa5270277199b63666456$exports).default,
  "cs-CZ": _babelRuntimeHelpersInteropRequireDefault($c2158ac3aac63d05c0787f91c5e6$exports).default,
  "da-DK": _babelRuntimeHelpersInteropRequireDefault($f7aea96abdaae1eb301c63fe67ff9fa$exports).default,
  "de-DE": _babelRuntimeHelpersInteropRequireDefault($f3491c664171e6b5e47db3baca390e$exports).default,
  "el-GR": _babelRuntimeHelpersInteropRequireDefault($da631def8a53d3d7ca63b5a989a2$exports).default,
  "en-US": _babelRuntimeHelpersInteropRequireDefault($fb4c477a38a74b935d35db24ae7$exports).default,
  "es-ES": _babelRuntimeHelpersInteropRequireDefault($b6fd69f9d5c0d1736b0ffb60159dbd4$exports).default,
  "et-EE": _babelRuntimeHelpersInteropRequireDefault($ba5713ed42715892c62c91f4a61185db$exports).default,
  "fi-FI": _babelRuntimeHelpersInteropRequireDefault($d425c7f620a7cd6fec958b2d805b4748$exports).default,
  "fr-FR": _babelRuntimeHelpersInteropRequireDefault($a53b9b9e4ee3c32689ca1c9d37$exports).default,
  "he-IL": _babelRuntimeHelpersInteropRequireDefault($c53806192c6b46eb32dc82efae908cb$exports).default,
  "hr-HR": _babelRuntimeHelpersInteropRequireDefault($cbbca9d8ba35e50d9d74ddc492ac95d5$exports).default,
  "hu-HU": _babelRuntimeHelpersInteropRequireDefault($b6e1f06770a0ad8a02049cb304d$exports).default,
  "it-IT": _babelRuntimeHelpersInteropRequireDefault($b6c1d31d04e4e80df25d89ebefb38d6c$exports).default,
  "ja-JP": _babelRuntimeHelpersInteropRequireDefault($a858c6dc87cf51add44cd600186b$exports).default,
  "ko-KR": _babelRuntimeHelpersInteropRequireDefault($bce3a6596f5d6bce7af4e1cdfe714b9$exports).default,
  "lt-LT": _babelRuntimeHelpersInteropRequireDefault($a80424d4da258b90efdca51671420e98$exports).default,
  "lv-LV": _babelRuntimeHelpersInteropRequireDefault($b7b9bc8c0cfc6eec9fa971e7b25cd656$exports).default,
  "nb-NO": _babelRuntimeHelpersInteropRequireDefault($e985758bae9fabb24500c21a0a00b725$exports).default,
  "nl-NL": _babelRuntimeHelpersInteropRequireDefault($f05d419963f6daeda3bc9dbbe3cc02bd$exports).default,
  "pl-PL": _babelRuntimeHelpersInteropRequireDefault($c8fa3e85daf6d04ed07583e629c87ce4$exports).default,
  "pt-BR": _babelRuntimeHelpersInteropRequireDefault($f06e8ad24001ed35ea808810226a15$exports).default,
  "ro-RO": _babelRuntimeHelpersInteropRequireDefault($a20ad400f1086b2bea7f9791d7257ad$exports).default,
  "ru-RU": _babelRuntimeHelpersInteropRequireDefault($fc28441a9133071c2297a09b6b420dd$exports).default,
  "sk-SK": _babelRuntimeHelpersInteropRequireDefault($a91ecad4479ad50b50aa177a2506dc$exports).default,
  "sl-SI": _babelRuntimeHelpersInteropRequireDefault($f9693ead50748c9beb107ad23956eb9$exports).default,
  "sr-SP": _babelRuntimeHelpersInteropRequireDefault($b5e22101ce830f7d95581df69464b$exports).default,
  "sv-SE": _babelRuntimeHelpersInteropRequireDefault($c0b006e739315f2d0109fd704d505d4d$exports).default,
  "tr-TR": _babelRuntimeHelpersInteropRequireDefault($b2fcb8208d40a3677791cb274f5c23$exports).default,
  "uk-UA": _babelRuntimeHelpersInteropRequireDefault($bedf08a338a4a9658a5b3265b7ba64$exports).default,
  "zh-CN": _babelRuntimeHelpersInteropRequireDefault($b49f1939211bfd9e1f4f626061efad44$exports).default,
  "zh-TW": _babelRuntimeHelpersInteropRequireDefault($a878720d2a5fd83cfd5a0f74b64957e$exports).default
};

/**
 * A visually hidden button that can be used to allow screen reader
 * users to dismiss a modal or popup when there is no visual
 * affordance to do so.
 */
function DismissButton(props) {
  let {
    onDismiss
  } = props;
  let formatMessage = useMessageFormatter($e0a65de2c0deb9a27bf483be129a43c1$var$intlMessages);

  let onClick = () => {
    if (onDismiss) {
      onDismiss();
    }
  };

  return /*#__PURE__*/_react.createElement(VisuallyHidden, null, /*#__PURE__*/_react.createElement("button", {
    tabIndex: -1,
    "aria-label": formatMessage('dismiss'),
    onClick: onClick
  }));
}

exports.DismissButton = DismissButton;
//# sourceMappingURL=main.js.map
