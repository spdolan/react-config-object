import { useState, useEffect, useReducer, useMemo } from "react";
import _babelRuntimeHelpersEsmExtends from "@babel/runtime/helpers/esm/extends";

/**
 * Manages state for an immutable list data structure, and provides convenience methods to
 * update the data over time.
 */
export function useListData(options) {
  let {
    initialItems = [],
    initialSelectedKeys,
    getKey = item => item.id || item.key
  } = options;
  let [state, setState] = useState({
    items: initialItems,
    selectedKeys: initialSelectedKeys === 'all' ? 'all' : new Set(initialSelectedKeys || [])
  });
  return _babelRuntimeHelpersEsmExtends({}, state, $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions({
    getKey
  }, setState), {
    getItem(key) {
      return state.items.find(item => getKey(item) === key);
    }

  });
}

function $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index) {
  for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
    values[_key - 2] = arguments[_key];
  }

  return _babelRuntimeHelpersEsmExtends({}, state, {
    items: [...state.items.slice(0, index), ...values, ...state.items.slice(index)]
  });
}

function $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions(opts, dispatch) {
  let {
    getKey
  } = opts;
  return {
    setSelectedKeys(selectedKeys) {
      dispatch(state => _babelRuntimeHelpersEsmExtends({}, state, {
        selectedKeys
      }));
    },

    insert(index) {
      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index, ...values));
    },

    insertBefore(key) {
      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        values[_key3 - 1] = arguments[_key3];
      }

      dispatch(state => {
        let index = state.items.findIndex(item => getKey(item) === key);

        if (index === -1) {
          return;
        }

        return $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index, ...values);
      });
    },

    insertAfter(key) {
      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        values[_key4 - 1] = arguments[_key4];
      }

      dispatch(state => {
        let index = state.items.findIndex(item => getKey(item) === key);

        if (index === -1) {
          return;
        }

        return $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, index + 1, ...values);
      });
    },

    prepend() {
      for (var _len5 = arguments.length, values = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++) {
        values[_key5] = arguments[_key5];
      }

      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, 0, ...values));
    },

    append() {
      for (var _len6 = arguments.length, values = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        values[_key6] = arguments[_key6];
      }

      dispatch(state => $b778f1542e2cf1e9d9f1c7276a173aec$var$insert(state, state.items.length, ...values));
    },

    remove() {
      for (var _len7 = arguments.length, keys = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++) {
        keys[_key7] = arguments[_key7];
      }

      dispatch(state => {
        let keySet = new Set(keys);
        let items = state.items.filter(item => !keySet.has(getKey(item)));
        let selection = new Set(state.selectedKeys);

        for (let key of keys) {
          selection.delete(key);
        }

        return _babelRuntimeHelpersEsmExtends({}, state, {
          items,
          selectedKeys: selection
        });
      });
    },

    removeSelectedItems() {
      dispatch(state => {
        if (state.selectedKeys === 'all') {
          return _babelRuntimeHelpersEsmExtends({}, state, {
            items: [],
            selectedKeys: new Set()
          });
        }

        let selectedKeys = state.selectedKeys;
        let items = state.items.filter(item => !selectedKeys.has(getKey(item)));
        return _babelRuntimeHelpersEsmExtends({}, state, {
          items,
          selectedKeys: new Set()
        });
      });
    },

    move(key, toIndex) {
      dispatch(state => {
        let index = state.items.findIndex(item => getKey(item) === key);

        if (index === -1) {
          return state;
        }

        let copy = state.items.slice();
        let [item] = copy.splice(index, 1);
        copy.splice(toIndex, 0, item);
        return _babelRuntimeHelpersEsmExtends({}, state, {
          items: copy
        });
      });
    },

    update(key, newValue) {
      dispatch(state => {
        let index = state.items.findIndex(item => getKey(item) === key);

        if (index === -1) {
          return state;
        }

        return _babelRuntimeHelpersEsmExtends({}, state, {
          items: [...state.items.slice(0, index), newValue, ...state.items.slice(index + 1)]
        });
      });
    }

  };
}

function $ebfe0ef2c160f1de1367205924a0b01e$var$reducer(data, action) {
  var _action$sortDescripto, _action$selectedKeys, _action$sortDescripto2, _action$selectedKeys2, _action$sortDescripto3;

  switch (data.state) {
    case 'idle':
    case 'error':
      switch (action.type) {
        case 'loading':
        case 'loadingMore':
        case 'sorting':
          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: action.type,
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === 'loading' ? [] : data.items,
            sortDescriptor: (_action$sortDescripto = action.sortDescriptor) != null ? _action$sortDescripto : data.sortDescriptor,
            abortController: action.abortController
          });

        case 'update':
          return _babelRuntimeHelpersEsmExtends({}, data, action.updater(data));

        case 'success':
        case 'error':
          return data;

        default:
          throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
      }

    case 'loading':
    case 'sorting':
      switch (action.type) {
        case 'success':
          // Ignore if there is a newer abortcontroller in state.
          // This means that multiple requests were going at once.
          // We want to take only the latest result.
          if (action.abortController !== data.abortController) {
            return data;
          }

          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: 'idle',
            items: [...action.items],
            selectedKeys: new Set((_action$selectedKeys = action.selectedKeys) != null ? _action$selectedKeys : data.selectedKeys),
            sortDescriptor: (_action$sortDescripto2 = action.sortDescriptor) != null ? _action$sortDescripto2 : data.sortDescriptor,
            abortController: null,
            cursor: action.cursor
          });

        case 'error':
          if (action.abortController !== data.abortController) {
            return data;
          }

          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: 'error',
            error: action.error,
            abortController: null
          });

        case 'loading':
        case 'loadingMore':
        case 'sorting':
          // We're already loading, and another load was triggered at the same time.
          // We need to abort the previous load and start a new one.
          data.abortController.abort();
          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: action.type,
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === 'loading' ? [] : data.items,
            abortController: action.abortController
          });

        default:
          throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
      }

    case 'loadingMore':
      switch (action.type) {
        case 'success':
          // Append the new items
          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: 'idle',
            items: [...data.items, ...action.items],
            selectedKeys: new Set([...data.selectedKeys, ...((_action$selectedKeys2 = action.selectedKeys) != null ? _action$selectedKeys2 : [])]),
            sortDescriptor: (_action$sortDescripto3 = action.sortDescriptor) != null ? _action$sortDescripto3 : data.sortDescriptor,
            abortController: null,
            cursor: action.cursor
          });

        case 'error':
          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: 'error',
            error: action.error
          });

        case 'loading':
        case 'sorting':
          // We're already loading more, and another load was triggered at the same time.
          // We need to abort the previous load more and start a new one.
          data.abortController.abort();
          return _babelRuntimeHelpersEsmExtends({}, data, {
            state: 'loading',
            // Reset items to an empty list if loading, but not when sorting.
            items: action.type === 'loading' ? [] : data.items,
            abortController: action.abortController
          });

        default:
          throw new Error("Invalid action \"" + action.type + "\" in state \"" + data.state + "\"");
      }

    default:
      throw new Error("Invalid state \"" + data.state + "\"");
  }
}
/**
 * Manages state for an immutable async loaded list data structure, and provides convenience methods to
 * update the data over time. Manages loading and error states, pagination, and sorting.
 */


export function useAsyncList(options) {
  const {
    load,
    sort,
    initialSelectedKeys,
    initialSortDescriptor,
    getKey = item => item.id || item.key
  } = options;
  let [data, dispatch] = useReducer($ebfe0ef2c160f1de1367205924a0b01e$var$reducer, {
    state: 'idle',
    error: null,
    items: [],
    selectedKeys: new Set(initialSelectedKeys),
    sortDescriptor: initialSortDescriptor
  });

  const dispatchFetch = async (action, fn) => {
    let abortController = new AbortController();

    try {
      var _action$sortDescripto4;

      dispatch(_babelRuntimeHelpersEsmExtends({}, action, {
        abortController
      }));
      let response = await fn({
        items: data.items.slice(),
        selectedKeys: data.selectedKeys,
        sortDescriptor: (_action$sortDescripto4 = action.sortDescriptor) != null ? _action$sortDescripto4 : data.sortDescriptor,
        signal: abortController.signal,
        cursor: action.type === 'loadingMore' ? data.cursor : null
      });
      dispatch(_babelRuntimeHelpersEsmExtends({
        type: 'success'
      }, response, {
        abortController
      }));
    } catch (e) {
      dispatch({
        type: 'error',
        error: e,
        abortController
      });
    }
  };

  useEffect(() => {
    dispatchFetch({
      type: 'loading'
    }, load); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return _babelRuntimeHelpersEsmExtends({
    items: data.items,
    selectedKeys: data.selectedKeys,
    sortDescriptor: data.sortDescriptor,
    isLoading: data.state === 'loading' || data.state === 'loadingMore' || data.state === 'sorting',
    error: data.error,

    getItem(key) {
      return data.items.find(item => getKey(item) === key);
    },

    reload() {
      dispatchFetch({
        type: 'loading'
      }, load);
    },

    loadMore() {
      // Ignore if already loading more.
      if (data.state === 'loadingMore' || data.cursor == null) {
        return;
      }

      dispatchFetch({
        type: 'loadingMore'
      }, load);
    },

    sort(sortDescriptor) {
      dispatchFetch({
        type: 'sorting',
        sortDescriptor
      }, sort || load);
    }

  }, $b778f1542e2cf1e9d9f1c7276a173aec$export$createListActions(_babelRuntimeHelpersEsmExtends({}, options, {
    getKey
  }), fn => {
    dispatch({
      type: 'update',
      updater: fn
    });
  }));
}

/**
 * Manages state for an immutable tree data structure, and provides convenience methods to
 * update the data over time.
 */
export function useTreeData(options) {
  let {
    initialItems = [],
    initialSelectedKeys,
    getKey = item => item.id || item.key,
    getChildren = item => item.children
  } = options;
  let map = useMemo(() => new Map(), []); // We only want to compute this on initial render.
  // eslint-disable-next-line react-hooks/exhaustive-deps

  let initialNodes = useMemo(() => buildTree(initialItems), []);
  let [items, setItems] = useState(initialNodes);
  let [selectedKeys, setSelectedKeys] = useState(new Set(initialSelectedKeys || []));

  function buildTree(initialItems, parentKey) {
    return initialItems.map(item => {
      let node = {
        key: getKey(item),
        parentKey: parentKey,
        value: item,
        children: null
      };
      node.children = buildTree(getChildren(item), node.key);
      map.set(node.key, node);
      return node;
    });
  }

  function updateTree(items, key, update) {
    let node = map.get(key);

    if (!node) {
      return items;
    } // Create a new node. If null, then delete the node, otherwise replace.


    let newNode = update(node);

    if (newNode == null) {
      deleteNode(node);
    } else {
      map.set(key, newNode);
    } // Walk up the tree and update each parent to refer to the new chilren.


    while (node.parentKey) {
      let nextParent = map.get(node.parentKey);
      let copy = {
        key: nextParent.key,
        parentKey: nextParent.parentKey,
        value: nextParent.value,
        children: null
      };
      let children = nextParent.children;

      if (newNode == null) {
        children = children.filter(c => c !== node);
      }

      copy.children = children.map(child => {
        if (child === node) {
          return newNode;
        }

        return child;
      });
      map.set(copy.key, copy);
      newNode = copy;
      node = nextParent;
    }

    if (newNode == null) {
      items = items.filter(c => c !== node);
    }

    return items.map(item => {
      if (item === node) {
        return newNode;
      }

      return item;
    });
  }

  function deleteNode(node) {
    map.delete(node.key);

    for (let child of node.children) {
      deleteNode(child);
    }
  }

  return {
    items,
    selectedKeys,
    setSelectedKeys,

    getItem(key) {
      return map.get(key);
    },

    insert(parentKey, index) {
      for (var _len = arguments.length, values = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
        values[_key - 2] = arguments[_key];
      }

      setItems(items => {
        let nodes = buildTree(values, parentKey); // If parentKey is null, insert into the root.

        if (parentKey == null) {
          return [...items.slice(0, index), ...nodes, ...items.slice(index)];
        } // Otherwise, update the parent node and its ancestors.


        return updateTree(items, parentKey, parentNode => ({
          key: parentNode.key,
          parentKey: parentNode.parentKey,
          value: parentNode.value,
          children: [...parentNode.children.slice(0, index), ...nodes, ...parentNode.children.slice(index)]
        }));
      });
    },

    insertBefore(key) {
      let node = map.get(key);

      if (!node) {
        return;
      }

      let parentNode = map.get(node.parentKey);
      let nodes = parentNode ? parentNode.children : items;
      let index = nodes.indexOf(node);

      for (var _len2 = arguments.length, values = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {
        values[_key2 - 1] = arguments[_key2];
      }

      this.insert(parentNode == null ? void 0 : parentNode.key, index, ...values);
    },

    insertAfter(key) {
      let node = map.get(key);

      if (!node) {
        return;
      }

      let parentNode = map.get(node.parentKey);
      let nodes = parentNode ? parentNode.children : items;
      let index = nodes.indexOf(node);

      for (var _len3 = arguments.length, values = new Array(_len3 > 1 ? _len3 - 1 : 0), _key3 = 1; _key3 < _len3; _key3++) {
        values[_key3 - 1] = arguments[_key3];
      }

      this.insert(parentNode == null ? void 0 : parentNode.key, index + 1, ...values);
    },

    prepend(parentKey) {
      for (var _len4 = arguments.length, values = new Array(_len4 > 1 ? _len4 - 1 : 0), _key4 = 1; _key4 < _len4; _key4++) {
        values[_key4 - 1] = arguments[_key4];
      }

      this.insert(parentKey, 0, ...values);
    },

    append(parentKey) {
      for (var _len5 = arguments.length, values = new Array(_len5 > 1 ? _len5 - 1 : 0), _key5 = 1; _key5 < _len5; _key5++) {
        values[_key5 - 1] = arguments[_key5];
      }

      if (parentKey == null) {
        this.insert(null, items.length, ...values);
      } else {
        let parentNode = map.get(parentKey);

        if (!parentNode) {
          return;
        }

        this.insert(parentKey, parentNode.children.length, ...values);
      }
    },

    remove() {
      let newItems = items;

      for (var _len6 = arguments.length, keys = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++) {
        keys[_key6] = arguments[_key6];
      }

      for (let key of keys) {
        newItems = updateTree(newItems, key, () => null);
      }

      setItems(newItems);
      let selection = new Set(selectedKeys);

      for (let key of selectedKeys) {
        if (!map.has(key)) {
          selection.delete(key);
        }
      }

      setSelectedKeys(selection);
    },

    removeSelectedItems() {
      this.remove(...selectedKeys);
    },

    move(key, toParentKey, index) {
      setItems(items => {
        let node = map.get(key);

        if (!node) {
          return items;
        }

        items = updateTree(items, key, () => null);
        return updateTree(items, toParentKey, parentNode => ({
          key: parentNode.key,
          parentKey: parentNode.parentKey,
          value: parentNode.value,
          children: [...parentNode.children.slice(0, index), node, ...parentNode.children.slice(index)]
        }));
      });
    },

    update(oldKey, newValue) {
      setItems(items => updateTree(items, oldKey, oldNode => {
        let node = {
          key: oldNode.key,
          parentKey: oldNode.key,
          value: newValue,
          children: null
        };
        node.children = buildTree(getChildren(newValue), node.key);
        return node;
      }));
    }

  };
}
//# sourceMappingURL=module.js.map
